<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 06-concurrency：並行処理とランタイム

## はじめに

[01-runtime](./01-runtime.md) で、ランタイムの責務の一つとして「言語固有機能の実現」を学びました

Go の goroutine や Python の async/await は、ランタイムが実現している機能です

前のシリーズでは、OS が提供するスレッドを学びました

しかし、goroutine は「軽量スレッド」と呼ばれます

OS のスレッドと何が違うのでしょうか？

このページでは、並行処理とランタイムの関係を学びます

### 日常の例え

レストランのキッチンを想像してください

<strong>プロセス</strong>は、キッチン全体です

一つのキッチンで、複数の料理を同時に作ります

<strong>OS スレッド</strong>は、シェフです

シェフ 1 人が、1 つの CPU コアを使って作業します

シェフが増えれば、同時に作れる料理は増えますが、キッチンが狭くなります

<strong>goroutine やコルーチン</strong>は、シェフが同時にこなす複数の料理です

1 人のシェフが、パスタを茹でながらソースを煮込み、同時にサラダを盛り付ける

待ち時間（茹で時間など）を活用して、複数の作業を効率的にこなします

<strong>ランタイムスケジューラ</strong>は、店長です

どのシェフがどの料理を担当するか、どの順番で作業するかを決めます

| 概念                 | 日常の例え                                                   |
| -------------------- | ------------------------------------------------------------ |
| プロセス             | レストランのキッチン                                         |
| OS スレッド          | シェフ                                                       |
| goroutine/コルーチン | シェフが同時に作る料理                                       |
| コンテキストスイッチ | シェフが別の料理に切り替え                                   |
| スケジューラ         | 店長（作業の割り当て）                                       |
| GIL                  | コンロが 1 つしかなく、同時に 1 人のシェフしか使えないルール |

### このページで学ぶこと

このページでは、以下の概念を学びます

- <strong>並行処理の 3 つのモデル</strong>
  - OS スレッド、軽量スレッド、async/await
- <strong>OS スレッドとの関係</strong>
  - ランタイムはどうやって OS スレッドを使うか
- <strong>ランタイムスケジューラ</strong>
  - goroutine やコルーチンをどうやって管理するか
- <strong>GIL（Python）</strong>
  - なぜ Python は「真の並列処理」が難しいのか

---

## 目次

1. [並行と並列の違い](#並行と並列の違い)
2. [並行処理の 3 つのモデル](#並行処理の-3-つのモデル)
3. [OS スレッドとは](#os-スレッドとは)
4. [軽量スレッドとは](#軽量スレッドとは)
5. [async/await とは](#asyncawait-とは)
6. [ランタイムスケジューラ](#ランタイムスケジューラ)
7. [GIL：Python の制約](#gilpython-の制約)
8. [用語集](#用語集)
9. [参考資料](#参考資料)
10. [次のステップ](#次のステップ)

---

## 並行と並列の違い

まず、「並行」と「並列」の違いを明確にしましょう

### 並行（Concurrency）

<strong>並行</strong>は、複数のタスクを「扱う」能力です

同時に進行しているように見えますが、実際には高速に切り替えているかもしれません

1 人のシェフが、複数の料理を同時に作っている状態です

### 並列（Parallelism）

<strong>並列</strong>は、複数のタスクを「同時に実行する」ことです

複数の CPU コアで、実際に同時に処理が行われます

複数のシェフが、同時に別々の料理を作っている状態です

### 関係

| 状況                   | 並行 | 並列 | 補足                               |
| ---------------------- | ---- | ---- | ---------------------------------- |
| 1 コア、1 スレッド     | なし | なし | 1 つのタスクを順番に処理           |
| 1 コア、複数スレッド   | あり | なし | 複数タスクを切り替えながら処理     |
| 複数コア、複数スレッド | あり | あり | 複数タスクを本当に同時に処理できる |

並行は「設計の話」、並列は「実行の話」です

並行に設計されたプログラムは、並列に実行できる可能性があります

---

## 並行処理の 3 つのモデル

言語やランタイムが提供する並行処理モデルには、大きく 3 つがあります

### 1. OS スレッド

OS が提供するスレッド（pthread など）を直接使う方式です

| 特徴       | 説明                      |
| ---------- | ------------------------- |
| 管理者     | OS（カーネル）            |
| 生成コスト | 高い（数十〜数百μs）      |
| メモリ消費 | 大きい（スタック 1〜8MB） |
| 切り替え   | 重い（カーネル介入）      |

C 言語や Java で `pthread` や `Thread` を使うと、この方式になります

### 2. 軽量スレッド（グリーンスレッド）

ランタイムがユーザー空間で管理するスレッドです

<strong>軽量スレッド</strong>と<strong>グリーンスレッド</strong>は、ほぼ同じ意味で使われます

<strong>コルーチン</strong>は「中断と再開が可能な関数」であり、関数レベルの仕組みです

軽量スレッドは、このコルーチンの仕組みを内部で利用しつつ、ランタイムのスケジューラが管理する<strong>実行単位</strong>です

つまり、コルーチンが「中断・再開の仕組み」を提供し、軽量スレッドがその仕組みの上に「スケジューリング」を加えた存在です

| 特徴       | 説明                         |
| ---------- | ---------------------------- |
| 管理者     | ランタイム（ユーザー空間）   |
| 生成コスト | 低い（数μs）                 |
| メモリ消費 | 小さい（スタック数 KB 程度） |
| 切り替え   | 軽い（ユーザー空間で完結）   |

Go の goroutine がこの方式の代表です

### 3. async/await

<strong>イベントループ</strong>（I/O の完了を監視し、実行可能なタスクを順番に実行する仕組み）と、<strong>協調的</strong>なタスク切り替えを使う方式です

「協調的」とは、タスク自身が実行を譲るタイミングを決める方式を意味します

async/await では `await` を書いた場所でのみ切り替えが起き、OS スレッドのように外部から強制的に中断されることはありません

イベントループの詳しい動作は[後述](#asyncawait-とは)します

| 特徴       | 説明                                        |
| ---------- | ------------------------------------------- |
| 管理者     | イベントループ                              |
| 生成コスト | 非常に低い                                  |
| メモリ消費 | 小さい                                      |
| 切り替え   | 協調的（タスク自身が await で自発的に譲る） |

JavaScript、Python の asyncio、Rust の async がこの方式です

### 比較表

「大量 I/O の効率」は、ネットワーク通信やファイル読み書きなど、I/O 待ちが多い処理を大量に同時処理する効率を表します

| モデル       | 管理者         | 並列実行 | 大量 I/O の効率 | CPU バウンド |
| ------------ | -------------- | -------- | --------------- | ------------ |
| OS スレッド  | OS             | 可能     | 普通            | 得意         |
| 軽量スレッド | ランタイム     | 可能     | 良い            | 得意         |
| async/await  | イベントループ | 難しい   | 非常に良い      | 苦手         |

async/await が CPU バウンド（計算中心の処理）に弱いのは、協調的な仕組みのため計算中に `await` で譲る機会がないからです（[詳細](#asyncawait-とは)）

---

## OS スレッドとは

### 基本的な仕組み

OS スレッドは、カーネルが管理するスレッドです

前のシリーズで詳しく学びました

各スレッドは、独自のスタックを持ちますが、ヒープや他のリソースはプロセス内で共有します

### コンテキストスイッチ

OS スレッドを切り替えるとき、<strong>コンテキストスイッチ</strong>が発生します

| 保存されるもの     | 説明                       |
| ------------------ | -------------------------- |
| CPU レジスタ       | 現在の実行状態             |
| スタックポインタ   | 現在のスタック位置         |
| プログラムカウンタ | 次に実行する命令のアドレス |

コンテキストスイッチには、カーネルへの移行が必要なため、オーバーヘッドがあります

### OS スレッドの限界

OS スレッドは強力ですが、大量に作るには向いていません

| 問題           | 説明                               |
| -------------- | ---------------------------------- |
| メモリ消費     | 1 スレッドあたり 1〜8MB のスタック |
| 生成コスト     | スレッド生成は比較的重い           |
| 切り替えコスト | カーネル介入が必要                 |

1 万個の同時接続を処理する Web サーバーで、1 接続 = 1 スレッドだと、メモリだけで数 GB 必要になります

---

## 軽量スレッドとは

### M:N スケジューリング

軽量スレッド（グリーンスレッド）は、<strong>M:N スケジューリング</strong>を使います

M 個の軽量スレッドを、N 個の OS スレッド上で実行します

```
軽量スレッド:  G1  G2  G3  G4  G5  G6  G7  G8  (M = 8)
                ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
OS スレッド:   [  T1  ] [  T2  ] [  T3  ] [  T4  ] (N = 4)
                  ↓         ↓         ↓        ↓
CPU コア:        Core1    Core2    Core3    Core4
```

ランタイムが、どの軽量スレッドをどの OS スレッドで実行するかを管理します

### goroutine（Go）

Go の<strong>goroutine</strong>は、軽量スレッドの代表例です

| 特徴             | 説明                         |
| ---------------- | ---------------------------- |
| 生成             | `go func()` で簡単に作成     |
| スタック         | 数 KB 程度、必要に応じて拡張 |
| スケジューリング | Go ランタイムが管理          |

goroutine は非常に軽量で、数十万個作っても問題ありません

```go
for i := 0; i < 100000; i++ {
    go func() {
        /* 何か処理 */
    }()
}
```

### なぜ軽量か

| 観点       | OS スレッド  | goroutine       |
| ---------- | ------------ | --------------- |
| スタック   | 1〜8MB 固定  | 数 KB〜（可変） |
| 生成コスト | 数十μs       | 数μs            |
| 切り替え   | カーネル介入 | ユーザー空間    |

軽量スレッドは、OS を介さずにランタイム内で管理されるため、オーバーヘッドが小さいのです

---

## async/await とは

### イベント駆動

<strong>async/await</strong>は、イベント駆動の並行処理モデルです

タスクは、自発的に実行を譲ります（<strong>協調的マルチタスク</strong>）

```python
async def fetch_data():
    response = await http_get("https://example.com")  # ここで譲る
    return response.text
```

`await` で I/O を待っている間、他のタスクが実行されます

### イベントループ

async/await の中心には<strong>イベントループ</strong>があります

```
1. 実行可能なタスクを選ぶ
2. タスクを実行（await まで）
3. await で I/O を待つタスクを登録
4. I/O 完了通知を受け取る
5. 完了したタスクを実行可能キューに戻す
6. 1 に戻る
```

### JavaScript の例

JavaScript は、シングルスレッドでイベントループを実行します

```javascript
async function fetchData() {
  const response = await fetch("https://example.com");
  return response.json();
}

fetchData().then((data) => console.log(data));
```

`await` で HTTP リクエストを待っている間、他の JavaScript コードが実行されます

### 向いている用途

async/await は、<strong>I/O バウンド</strong>な処理に向いています

| 用途         | 適性                             |
| ------------ | -------------------------------- |
| Web サーバー | 良い（多数の接続を効率的に処理） |
| ファイル I/O | 良い（読み書きの待ち時間を活用） |
| CPU 計算     | 悪い（計算中は譲れない）         |

CPU 計算が向かない理由は、async/await が協調的マルチタスクだからです

タスクは `await` で自発的に譲りますが、計算中は `await` を書く場所がありません

結果として、計算が終わるまで他のタスクが実行されず、イベントループがブロックされます

---

## ランタイムスケジューラ

### Go の GMP モデル

Go のランタイムスケジューラは、<strong>GMP モデル</strong>で設計されています

| 構成要素 | 説明                        |
| -------- | --------------------------- |
| G        | Goroutine（軽量スレッド）   |
| M        | Machine（OS スレッド）      |
| P        | Processor（論理プロセッサ） |

P は「G を実行するための権利」を持つ構造体です

P の数は GOMAXPROCS で決まり、デフォルトは CPU コア数です

G が実行されるには、P を経由して M（OS スレッド）に割り当てられる必要があります

```
実行中:
  G1 → P1 → M1 → CPU Core 1
  G2 → P2 → M2 → CPU Core 2

P1 の実行待ちキュー:
  G3, G4（次に P1 で実行される goroutine）
```

### ワークスティーリング

Go のスケジューラは<strong>ワークスティーリング</strong>を採用しています

ある P が暇になったら、他の P から G を「盗んで」実行します

これにより、負荷が均等に分散されます

### プリエンプション

Go の goroutine は<strong>プリエンプション</strong>されます

長時間実行している goroutine は、強制的に中断されて他の goroutine に譲ります

これにより、1 つの goroutine が CPU を独占することを防ぎます

---

## GIL：Python の制約

### GIL とは

<strong>GIL（Global Interpreter Lock）</strong>は、<strong>CPython</strong> が持つ排他ロックです

CPython とは、Python の最も広く使われている実装です

Python という言語には複数の実装があり、CPython は C 言語で書かれた標準実装です

一度に 1 つの OS スレッドしか Python バイトコードを実行できません

```
スレッド 1: [Python 実行]--[待機]--[Python 実行]--
スレッド 2: --[待機]--[Python 実行]--[待機]--
               ↑          ↑          ↑
              GIL        GIL        GIL
```

### なぜ GIL があるのか

CPython のメモリ管理は<strong>参照カウント</strong>を使用しています

参照カウントについては [05-gc](./05-gc.md) で学びました

この参照カウントの仕組みは、スレッドセーフではありません

複数のスレッドが同時に参照カウントを変更すると、カウントがずれてメモリリークやクラッシュが発生します

GIL は、参照カウントの整合性を保つために必要です

#### 歴史的背景

CPython が作られた頃、マルチスレッドはまだ一般的ではありませんでした

インタプリタの内部データ構造をスレッドセーフにするのは複雑で、性能にも影響します

そこで CPython は GIL を導入しました

「同時に Python バイトコードを実行できるスレッドは 1 つだけ」という制約をかけることで、実装を単純に保ったのです

### GIL の影響

| タスクの種類 | GIL の影響                  |
| ------------ | --------------------------- |
| I/O バウンド | 小さい（I/O 中は GIL 解放） |
| CPU バウンド | 大きい（並列実行できない）  |

CPU バウンドな処理では、マルチスレッドにしても速くなりません

### 回避方法

| 方法           | 説明                          |
| -------------- | ----------------------------- |
| マルチプロセス | `multiprocessing` モジュール  |
| C 拡張         | GIL を解放して C コードを実行 |
| 別の実装       | PyPy、GraalPy など            |

### Free-threaded Python

<strong>Free-threaded Python</strong>は、GIL を無効化した CPython のビルドオプションです

GIL がないため、複数のスレッドが同時に Python バイトコードを実行できます

ただし、既存のライブラリとの互換性や安定性の面で注意が必要です

---

## 用語集

| 用語                 | 英語                     | 説明                                          |
| -------------------- | ------------------------ | --------------------------------------------- |
| 並行                 | Concurrency              | 複数のタスクを扱う能力                        |
| 並列                 | Parallelism              | 複数のタスクを同時に実行すること              |
| OS スレッド          | OS Thread                | カーネルが管理するスレッド                    |
| 軽量スレッド         | Lightweight Thread       | ランタイムが管理するスレッド                  |
| グリーンスレッド     | Green Thread             | ユーザー空間で管理されるスレッド              |
| goroutine            | goroutine                | Go の軽量スレッド                             |
| コルーチン           | Coroutine                | 中断と再開が可能な関数                        |
| async/await          | async/await              | 非同期処理の構文                              |
| イベントループ       | Event Loop               | イベントを監視して処理するループ              |
| イベント駆動         | Event-Driven             | イベントの発生に応じて処理を実行する方式      |
| 協調的マルチタスク   | Cooperative Multitasking | タスクが自発的に実行を譲る方式                |
| コンテキストスイッチ | Context Switch           | 実行中のスレッドを切り替えること              |
| M:N スケジューリング | M:N Scheduling           | M 個の軽量スレッドを N 個の OS スレッドで実行 |
| GIL                  | Global Interpreter Lock  | CPython の排他ロック                          |
| CPython              | CPython                  | C 言語で書かれた Python の標準実装            |
| Free-threaded Python | Free-threaded Python     | GIL を無効化した CPython のビルドオプション   |
| プリエンプション     | Preemption               | 実行中のタスクを強制的に中断すること          |
| ワークスティーリング | Work Stealing            | 暇なプロセッサが他から仕事を奪う方式          |
| I/O バウンド         | I/O Bound                | I/O 待ちが主なボトルネック                    |
| CPU バウンド         | CPU Bound                | CPU 処理が主なボトルネック                    |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>Go</strong>

- [The Go scheduler](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)
  - Go スケジューラの解説
- [Go Runtime](https://pkg.go.dev/runtime)
  - Go ランタイムのドキュメント

<strong>Python</strong>

- [threading - Thread-based parallelism](https://docs.python.org/3/library/threading.html)
  - Python のスレッドモジュール
- [asyncio - Asynchronous I/O](https://docs.python.org/3/library/asyncio.html)
  - Python の非同期 I/O
- [GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock)
  - GIL の解説

<strong>JavaScript</strong>

- [The event loop - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop)
  - JavaScript のイベントループ

<strong>OS スレッド</strong>

- [pthreads(7) - Linux manual page](https://man7.org/linux/man-pages/man7/pthreads.7.html)
  - POSIX スレッドの仕様

---

## 次のステップ

このトピックでは、並行処理とランタイムの関係を学びました

ランタイムは、OS が提供する機能の上に、より高レベルな並行処理モデルを実現しています

次の [07-ffi](./07-ffi.md) では、<strong>「言語間の橋渡し（FFI）」</strong>について学びます

- Python から C のライブラリを呼ぶ仕組み
- なぜ C が「共通語」になるのか
- FFI とシステムコールの関係

これらの疑問に答えていきます
