<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 04-stack-heap：スタックとヒープ

## はじめに

[01-runtime](./01-runtime.md) で、ランタイムの責務の一つとして「メモリ管理」を学びました

ランタイムは、スタックとヒープという 2 つのメモリ領域を管理しています

カーネル空間の学習では、プロセスのアドレス空間を学びました

そこでも、スタックとヒープが登場しました

このページでは、この 2 つのメモリ領域について深く学びます

なぜ 2 種類の領域が必要なのでしょうか？

それぞれ、どのように使われているのでしょうか？

### 日常の例え

デスクワークを想像してください

<strong>スタック</strong>は、あなたの<strong>机の上</strong>です

今やっている仕事の書類を、積み上げて使います

一番上の書類を処理し終わったら、それを片付けて、次の書類に取り掛かります

仕事が終われば、机の上は自動的に片付きます

<strong>ヒープ</strong>は、オフィスの<strong>本棚</strong>です

長期間保存する資料を置いておきます

どの位置からでもアクセスできますが、不要になったら自分で片付ける必要があります

放っておくと、本棚がいっぱいになってしまいます

| 概念             | 日常の例え                       |
| ---------------- | -------------------------------- |
| スタック         | 机の上（今の仕事の書類）         |
| ヒープ           | 本棚（長期保存の資料）           |
| スタックフレーム | 一つのタスクで使う書類セット     |
| メモリリーク     | 本棚に戻し忘れた資料が溜まること |

### このページで学ぶこと

このページでは、以下の概念を学びます

- <strong>スタックとは何か</strong>
  - LIFO 構造、関数呼び出しとの関係
- <strong>ヒープとは何か</strong>
  - 動的メモリ確保、長寿命のデータ
- <strong>なぜ 2 つ必要か</strong>
  - それぞれの役割と制限
- <strong>言語によるメモリモデルの違い</strong>
  - C、Java、Go、Rust のアプローチ

---

## 目次

1. [プロセスのメモリレイアウト](#プロセスのメモリレイアウト)
2. [スタックとは何か](#スタックとは何か)
3. [ヒープとは何か](#ヒープとは何か)
4. [なぜ 2 つ必要か](#なぜ-2-つ必要か)
5. [言語によるメモリモデルの違い](#言語によるメモリモデルの違い)
6. [スタックオーバーフロー](#スタックオーバーフロー)
7. [用語集](#用語集)
8. [参考資料](#参考資料)
9. [次のステップ](#次のステップ)

---

## プロセスのメモリレイアウト

まず、プロセスのメモリがどのように構成されているかを復習しましょう

### アドレス空間の構造

Linux プロセスのアドレス空間は、以下のような構造になっています

| 領域     | 内容                             | 方向       |
| -------- | -------------------------------- | ---------- |
| スタック | ローカル変数、関数の戻りアドレス | 下に伸びる |
| （空き） | 未使用領域                       |            |
| ヒープ   | 動的に確保されるメモリ           | 上に伸びる |
| BSS      | 未初期化のグローバル変数         |            |
| データ   | 初期化済みのグローバル変数       |            |
| テキスト | 実行可能コード                   |            |

スタックは高いアドレスから低いアドレスに向かって伸びます

ヒープは低いアドレスから高いアドレスに向かって伸びます

この 2 つが衝突しないように、十分な空き領域が確保されています

### /proc で確認する

実際のメモリレイアウトは `/proc/[pid]/maps` で確認できます

```bash
$ cat /proc/self/maps
555555554000-555555556000 r--p ... /bin/cat     # テキスト
555555556000-555555557000 r-xp ... /bin/cat     # テキスト（実行可能）
555555558000-555555559000 r--p ... /bin/cat     # データ
555555559000-55555555a000 rw-p ... /bin/cat     # データ（書き込み可能）
7ffff7c00000-7ffff7c28000 rw-p ...              # ヒープ
...
7ffffffde000-7ffffffff000 rw-p ... [stack]      # スタック
```

`[stack]` と表示されている領域がスタックです

---

## スタックとは何か

### LIFO 構造

<strong>スタック</strong>は、<strong>LIFO（Last In, First Out）</strong>構造のメモリ領域です

最後に積んだものを、最初に取り出します

皿を積み上げるイメージです

一番上の皿しか取れず、新しい皿は一番上に載せます

### 関数呼び出しとスタック

スタックは、関数呼び出しと密接に関係しています

関数が呼ばれるたびに、<strong>スタックフレーム</strong>が積まれます

関数が終了すると、そのスタックフレームは自動的に削除されます

```
main() が func_a() を呼ぶ
func_a() が func_b() を呼ぶ

スタックの状態：
┌─────────────┐
│ func_b のフレーム │ ← スタックトップ
├─────────────┤
│ func_a のフレーム │
├─────────────┤
│ main のフレーム   │
└─────────────┘

func_b が終了すると：
┌─────────────┐
│ func_a のフレーム │ ← スタックトップ
├─────────────┤
│ main のフレーム   │
└─────────────┘
```

### スタックフレームの中身

スタックフレームには、以下の情報が含まれます

| 内容               | 説明                                                                   |
| ------------------ | ---------------------------------------------------------------------- |
| 戻りアドレス       | 関数の処理が終わったとき、どこに戻ればよいかを覚えておくためのアドレス |
| 保存されたレジスタ | 呼び出し元のレジスタ値                                                 |
| ローカル変数       | 関数内で宣言された変数                                                 |
| 引数               | 関数に渡された引数（一部）                                             |

引数の一部は CPU のレジスタで渡されるため、すべてがスタックに置かれるわけではありません

C 言語で関数を書くと、ローカル変数はスタックに置かれます

```c
void func() {
    int x = 10;     /* スタックに配置 */
    int y = 20;     /* スタックに配置 */
    int z = x + y;  /* スタックに配置 */
}
/* 関数終了で自動的に解放 */
```

### スタックの特徴

| 特徴     | 説明                                |
| -------- | ----------------------------------- |
| 速度     | 非常に高速（ポインタ操作のみ）      |
| 管理     | 自動（関数終了で自動解放）          |
| サイズ   | 制限あり（通常数 MB、システム依存） |
| スコープ | 関数のスコープに限定                |

---

## ヒープとは何か

### 動的メモリ確保

<strong>ヒープ</strong>は、プログラムが実行中に動的にメモリを確保する領域です

C 言語では `malloc()` でメモリを確保し、`free()` で解放します

```c
int *p = malloc(sizeof(int) * 100);  /* ヒープから 400 バイト確保 */
/* ... pを使用 ... */
free(p);  /* 明示的に解放 */
```

### なぜヒープが必要か

スタックだけでは不十分な場合があります

<strong>サイズが実行時まで分からない場合</strong>

ユーザーの入力に応じてサイズが決まる配列など

```c
int n;
scanf("%d", &n);
int *arr = malloc(sizeof(int) * n);  /* n は実行時に決まる */
```

<strong>関数を超えて生き続ける必要がある場合</strong>

関数が終了してもデータを保持したい場合

```c
int* create_array() {
    int *p = malloc(sizeof(int) * 10);
    return p;  /* 関数終了後も p は有効 */
}
```

<strong>大きなデータを扱う場合</strong>

スタックには数 MB の制限があるため、大きなデータはヒープに置きます

### ヒープの特徴

| 特徴     | 説明                               |
| -------- | ---------------------------------- |
| 速度     | スタックより遅い（管理コストあり） |
| 管理     | 手動または GC                      |
| サイズ   | 仮想メモリの範囲で柔軟             |
| スコープ | プログラム全体からアクセス可能     |

### メモリリーク

ヒープメモリを解放し忘れると、<strong>メモリリーク</strong>が発生します

```c
void bad_function() {
    int *p = malloc(1000);
    /* free(p) を忘れた */
}  /* p へのポインタは失われたが、メモリは確保されたまま */
```

この関数を何度も呼ぶと、確保されたメモリがどんどん溜まっていきます

最終的にはメモリ不足になります

---

## なぜ 2 つ必要か

### 歴史的背景

Algol 言語が「ブロックスコープ」と「自動変数」を導入しました

関数に入るとローカル変数が自動的に確保され、関数から出ると自動的に解放される

この動作は<strong>スタック</strong>で実現されます

一方、関数の寿命を超えて存在するデータには、別の領域が必要でした

これが<strong>ヒープ</strong>の起源です

### それぞれの役割

スタックとヒープは、異なる用途に最適化されています

| 観点   | スタック                   | ヒープ               |
| ------ | -------------------------- | -------------------- |
| 速度   | 非常に高速                 | 比較的遅い           |
| 寿命   | 関数スコープ               | 明示的に解放するまで |
| サイズ | 固定（コンパイル時に決定） | 動的（実行時に決定） |
| 管理   | 自動                       | 手動または GC        |

<strong>スタックが得意なこと</strong>

- ローカル変数（サイズが小さく、スコープが限定的）
- 関数呼び出しの管理
- 高速なメモリ操作

<strong>ヒープが得意なこと</strong>

- 動的なサイズのデータ
- 関数を超えて生き続けるデータ
- 大きなデータ構造

### 使い分けの指針

```
サイズは小さい？ → スタック
スコープは関数内？ → スタック
サイズが実行時に決まる？ → ヒープ
関数を超えて使う？ → ヒープ
```

---

## 言語によるメモリモデルの違い

言語によって、スタックとヒープの扱いは大きく異なります

### C 言語：完全手動

C 言語では、プログラマが完全にメモリを管理します

| 操作       | 方法                   |
| ---------- | ---------------------- |
| スタック   | ローカル変数（自動）   |
| ヒープ確保 | `malloc()`、`calloc()` |
| ヒープ解放 | `free()`               |

C 言語の利点は、メモリの完全な制御が可能なことです

欠点は、メモリリークや二重解放などのバグが起きやすいことです

### Java：ヒープ中心 + GC

Java では、オブジェクトは基本的にヒープに配置されます

| 操作       | 方法                     |
| ---------- | ------------------------ |
| スタック   | プリミティブ型、参照変数 |
| ヒープ確保 | `new`                    |
| ヒープ解放 | GC が自動で行う          |

プログラマは `free()` を呼ぶ必要がありません

ガベージコレクタが不要なオブジェクトを自動的に回収します

### Go：エスケープ解析

Go は、コンパイラが<strong>エスケープ解析</strong>を行い、スタックとヒープを自動的に選択します

変数が関数のスコープを「逃げ出す（エスケープする）」かどうかを解析し、配置先を決定します

```go
func example() *int {
    x := 10        /* 関数内でのみ使用 → スタック */
    y := x + 10
    return &y      /* y のアドレスを返す → エスケープ（ヒープに配置） */
}
```

`y` は関数を超えて使われる（エスケープする）ため、ヒープに配置されます

`x` は `y` の計算に使われるだけで、関数の外には出ないため、スタックに配置されます

プログラマは意識する必要がありません

### Rust：所有権システム

Rust は<strong>所有権システム</strong>により、コンパイル時にメモリ安全性を保証します

| 概念         | 説明                               |
| ------------ | ---------------------------------- |
| 所有権       | 各値には一つの所有者がいる         |
| 借用         | 参照を借りる（所有権は移動しない） |
| ライフタイム | 参照の有効期間                     |

```rust
fn main() {
    let s1 = String::from("hello");  /* ヒープに確保、s1 が所有者 */
    let s2 = s1;                     /* 所有権が s2 に移動 */
    /* s1 はもう使えない */
}  /* s2 がスコープを抜けると自動解放 */
```

Rust では GC がなくても、メモリリークや二重解放が起きません

### 比較表

| 言語 | スタック/ヒープの選択 | 解放           | 安全性     |
| ---- | --------------------- | -------------- | ---------- |
| C    | プログラマが決定      | 手動           | 低い       |
| Java | ほぼヒープ            | GC 自動        | 高い       |
| Go   | コンパイラが決定      | GC 自動        | 高い       |
| Rust | コンパイラが決定      | 自動（所有権） | 非常に高い |

---

## スタックオーバーフロー

スタックには容量制限があります

この制限を超えると<strong>スタックオーバーフロー</strong>が発生します

### 発生原因

最も一般的な原因は、無限再帰です

```c
void infinite_recursion() {
    infinite_recursion();  /* 自分自身を呼び続ける */
}
```

関数を呼ぶたびにスタックフレームが積まれます

無限に呼び続けると、スタックが溢れます

### スタックサイズの確認

Linux では `ulimit` コマンドでスタックサイズを確認できます

```bash
$ ulimit -s
8192  # 8192 KB = 8 MB
```

### 対策

| 対策               | 説明                             |
| ------------------ | -------------------------------- |
| 再帰を避ける       | ループに書き換える               |
| 末尾再帰最適化     | 一部の言語・コンパイラがサポート |
| スタックサイズ増加 | `ulimit -s` で増やす（一時的）   |

---

## 用語集

| 用語                   | 英語                      | 説明                                                                         |
| ---------------------- | ------------------------- | ---------------------------------------------------------------------------- |
| スタック               | Stack                     | LIFO 構造のメモリ領域                                                        |
| ヒープ                 | Heap                      | 動的に確保されるメモリ領域                                                   |
| LIFO                   | Last In, First Out        | 後入れ先出し                                                                 |
| スタックフレーム       | Stack Frame               | 関数呼び出しごとに積まれるデータ                                             |
| ローカル変数           | Local Variable            | 関数内で宣言された変数                                                       |
| 動的メモリ確保         | Dynamic Memory Allocation | 実行時にメモリを確保すること                                                 |
| メモリリーク           | Memory Leak               | 解放されないメモリが蓄積すること                                             |
| スタックオーバーフロー | Stack Overflow            | スタック容量を超えること                                                     |
| エスケープ解析         | Escape Analysis           | 変数がスコープを超えるか判定する解析                                         |
| 所有権                 | Ownership                 | Rust のメモリ管理モデル                                                      |
| 二重解放               | Double Free               | 同じメモリを 2 回解放するバグ                                                |
| BSS                    | Block Started by Symbol   | 未初期化グローバル変数の領域（初期のアセンブラで使われていた疑似命令に由来） |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>メモリレイアウト</strong>

- [proc(5) - Linux manual page](https://man7.org/linux/man-pages/man5/proc.5.html)
  - `/proc/[pid]/maps` の詳細

<strong>C 言語のメモリ管理</strong>

- [malloc(3) - Linux manual page](https://man7.org/linux/man-pages/man3/malloc.3.html)
  - `malloc`、`free` の仕様

<strong>言語固有</strong>

- [Go Escape Analysis](https://go.dev/doc/faq#stack_or_heap)
  - Go のエスケープ解析
- [The Rust Programming Language - Ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)
  - Rust の所有権システム

<strong>スタック</strong>

- [getrlimit(2) - Linux manual page](https://man7.org/linux/man-pages/man2/getrlimit.2.html)
  - スタックサイズ制限の確認

---

## 次のステップ

このトピックでは、スタックとヒープの違いを学びました

Java や Go では、ヒープのメモリが自動的に解放されると説明しました

次の [05-gc](./05-gc.md) では、この自動解放の仕組みである<strong>「ガベージコレクション」</strong>について学びます

- GC はどうやって「不要なメモリ」を判断するのか
- 基本的な GC アルゴリズム
- GC のトレードオフ

これらの疑問に答えていきます
