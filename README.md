<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# read.runtime

<strong>「言語がプログラムを動かす仕組み」</strong>を学びます

---

## このリポジトリは何のためにあるのか

私たちは毎日、さまざまなプログラミング言語を使っています

Python でスクリプトを書いたり、JavaScript でウェブアプリを作ったり、Go でサーバーを動かしたり

でも、ちょっと考えてみてください

「プログラムを実行する」とき、言語は裏側で<strong>何をしている</strong>のでしょうか？

このリポジトリでは、その「裏側」を学びます

---

## 「ランタイム」とは何か

プログラムを書いて実行するとき、見えないところで「何か」が動いています

その「何か」が<strong>ランタイム</strong>です

### <strong>1. 言語によって異なる「動き方」</strong>

同じ「Hello World」を出力するプログラムでも、言語によって動き方が全く違います

- <strong>C 言語</strong>
  - コンパイルして機械語に変換し、CPU が直接実行する
- <strong>Python</strong>
  - インタプリタがソースコードをバイトコード（VM が理解できる中間形式）に変換し、仮想マシンで実行する
- <strong>Java</strong>
  - バイトコードに変換し、JVM（仮想マシン）が実行する
- <strong>Go</strong>
  - コンパイルして機械語に変換するが、ランタイムも一緒に埋め込まれる

これらの違いを生み出しているのが、言語ごとの「ランタイム」です

### <strong>2. ランタイムの役割</strong>

ランタイムは、以下のような仕事をしています

- <strong>メモリ管理</strong>
  - プログラムが使うメモリを確保・解放する
- <strong>ガベージコレクション</strong>
  - 使い終わったメモリを自動で片付ける（一部の言語）
- <strong>並行処理</strong>
  - 複数の処理を同時に行う仕組みを提供する
  - 例
    - goroutine（OS スレッドより軽量なスレッド）
    - async（非同期処理）
- <strong>OS との橋渡し</strong>
  - ファイルを開く、ネットワーク通信するなど、OS の機能を使う

### <strong>3. 前のシリーズとの関係</strong>

このリポジトリは、以下の学習の続きです

```
[ アプリケーション ]
        ↑
[ ランタイム / 言語実行基盤 ]      ← このリポジトリ
        ↑
[ OS（ユーザー空間） ]
        ↑
[ Linux カーネル（カーネル空間） ]
```

前のシリーズでは「OS がプログラムをどう動かすか」「OS 自身がどう動いているか」を学びました

このリポジトリでは、「言語がその上でどうプログラムを動かすか」を学びます

---

## なぜこれを学ぶのか

### <strong>1. 「なぜ」がわかるようになる</strong>

- なぜ Java は「Write Once, Run Anywhere（一度書けばどこでも動く）」なのか？
- なぜ Python は C より遅いと言われるのか？
- なぜ Go の goroutine は「軽い」のか？
- なぜ JavaScript は「シングルスレッド」なのに非同期処理ができるのか？

これらの疑問に答えるには、ランタイムの仕組みを知る必要があります

### <strong>2. 問題解決の視野が広がる</strong>

- プログラムがメモリを使いすぎているとき、何を確認すべきか？
- GC が原因でパフォーマンスが悪いとき、どう対処すべきか？
- C 言語のライブラリを他の言語から呼び出すとき、何に注意すべきか？

ランタイムの知識があれば、これらの問題に対処できます

### <strong>3. 言語選択の判断ができる</strong>

「この用途にはどの言語が適しているか？」を考えるとき、ランタイムの特性を知っていると、より良い判断ができます

---

## このリポジトリで学ぶこと

| 順番 | トピック                         | 学ぶこと                                                      |
| ---- | -------------------------------- | ------------------------------------------------------------- |
| 01   | [runtime](01-runtime.md)         | ランタイムとは何か、OS との関係                               |
| 02   | [compilation](02-compilation.md) | プログラムが「動く形」になるまで（インタプリタ / AOT / JIT）  |
| 03   | [vm](03-vm.md)                   | 仮想マシンとバイトコード（JVM, CPython, V8）                  |
| 04   | [stack-heap](04-stack-heap.md)   | スタックとヒープ（メモリの2つの使い方）                       |
| 05   | [gc](05-gc.md)                   | ガベージコレクション（なぜ必要か、基本アルゴリズム）          |
| 06   | [concurrency](06-concurrency.md) | 並行処理とランタイム（goroutine / コルーチン / async の正体） |
| 07   | [ffi](07-ffi.md)                 | 言語間の橋渡し（FFI）（C が「共通語」になる理由）             |

---

## 前提知識

このリポジトリを始める前に、以下を学習しておくことをおすすめします

- <strong>ユーザー空間の学習</strong>
  - プロセス、スレッド、メモリ構造の基礎
- <strong>カーネル空間の学習</strong>
  - システムコール、仮想メモリ、スケジューラの基礎

これらの知識がなくても読み進めることはできますが、「なぜランタイムがこうなっているか」の理解が深まります

---

## 参考資料

このリポジトリの内容は、以下のソースに基づいています

各トピックで使用する個別のドキュメントは、各トピックドキュメントに記載しています

- [The Java Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se21/html/index.html)
  - JVM の公式仕様
- [CPython Internals](https://devguide.python.org/internals/)
  - Python インタプリタの内部構造
- [Go Runtime](https://pkg.go.dev/runtime)
  - Go ランタイムの公式ドキュメント
- [V8 Documentation](https://v8.dev/docs)
  - V8 JavaScript エンジンのドキュメント
