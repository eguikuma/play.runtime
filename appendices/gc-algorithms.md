<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# GC アルゴリズムの多様性

## はじめに

[05-gc](../05-gc.md) で、基本的な GC アルゴリズム（参照カウント、マーク&スイープ、世代別 GC）を学びました

しかし、実際の GC 実装はより複雑で、多様なアルゴリズムが組み合わされています

このページでは、05-gc で触れなかったアルゴリズムと、実際の GC がどのように動作するかを深掘りします

---

## 目次

1. [コピー GC](#コピー-gc)
2. [増分 GC](#増分-gc)
3. [並行 GC の仕組み](#並行-gc-の仕組み)
4. [トライカラーマーキング](#トライカラーマーキング)
5. [ライトバリア](#ライトバリア)
6. [実際の GC 実装](#実際の-gc-実装)
7. [用語集](#用語集)
8. [参考資料](#参考資料)

---

## コピー GC

### 歴史的背景

Cheney は、生きているオブジェクトを別の領域にコピーする方式を提案しました

コピー後、元の領域は一括で解放できます

この方式は「Cheney のアルゴリズム」として知られています

### 基本的なアイデア

<strong>コピー GC</strong>（Semispace GC とも呼ばれる）は、ヒープを 2 つの領域に分ける方式です

| 領域      | 説明                                          |
| --------- | --------------------------------------------- |
| From 空間 | 現在オブジェクトが配置されている領域          |
| To 空間   | 空の領域（GC 後にオブジェクトがコピーされる） |

### 動作

1. 新しいオブジェクトを From 空間に配置
2. From 空間がいっぱいになったら GC を開始
3. ルートからたどれるオブジェクトを To 空間にコピー
4. From と To の役割を入れ替え
5. 古い From 空間（今の To 空間）は全体を一括でクリア

```
GC 前:
From空間: [A][B][C][D][E]  （A,C,E は生きている）
To空間:   [              ]

GC 後:
From空間: [              ]  （全体をクリア）
To空間:   [A][C][E]        （生きているオブジェクトだけコピー）
```

### メリット

<strong>フラグメンテーションがない</strong>

生きているオブジェクトを連続して配置するため、外部フラグメンテーションが発生しません

<strong>死んだオブジェクトのコストがゼロ</strong>

死んだオブジェクトは単に無視されます

領域を一括でクリアするため、個別に解放する必要がありません

<strong>高速な割り当て</strong>

次の空き位置を指すポインタを進めるだけで割り当てできます（バンプポインタ）

### デメリット

<strong>メモリ効率が悪い</strong>

常にヒープの半分が空いている必要があります

100MB を使いたければ、200MB のヒープが必要です

<strong>コピーのコスト</strong>

生きているオブジェクトをすべてコピーするため、長寿命のオブジェクトが多いと非効率です

### 世代別 GC との組み合わせ

コピー GC は、世代別 GC の Young 世代でよく使われます

Young 世代では「ほとんどのオブジェクトが死ぬ」ため、コピー GC の特性が活きます

- 死んだオブジェクト（多い）: コストなし
- 生きているオブジェクト（少ない）: コピーのみ

---

## 増分 GC

### Stop-the-World の問題

[05-gc](../05-gc.md) で、多くの GC は Stop-the-World（STW）を引き起こすと学びました

STW が長いと、アプリケーションの応答性が悪化します

### 増分 GC のアイデア

<strong>増分 GC</strong>は、GC の作業を小さな単位に分割し、アプリケーションと交互に実行します

```
通常の GC:
アプリ: [実行][      停止      ][実行]
GC:            [   GC 実行    ]

増分 GC:
アプリ: [実行][停][実行][停][実行][停][実行]
GC:           [GC]     [GC]     [GC]
```

### メリットとデメリット

| メリット       | デメリット             |
| -------------- | ---------------------- |
| 停止時間が短い | 全体の GC 時間は増える |
| 応答性が向上   | 実装が複雑             |

増分 GC を実現するには、アプリケーションが GC の途中でオブジェクトを変更しても正しく動作する仕組みが必要です

これは次に説明する「ライトバリア」で実現されます

---

## 並行 GC の仕組み

### 並行 GC とは

<strong>並行 GC</strong>は、GC スレッドとアプリケーションスレッドが同時に実行される方式です

```
アプリスレッド: [実行][実行][実行][実行][実行]
GC スレッド:       [マーク][マーク][マーク]
```

完全に STW をなくすことは難しいですが、停止時間を大幅に短縮できます

### 並行 GC の課題

アプリケーションが動いている間に GC を実行すると、問題が発生する可能性があります

<strong>問題: GC 中にオブジェクトが変更される</strong>

```
1. GC がオブジェクト A をマーク済みにする
2. アプリが A から B への参照を追加する
3. GC が B を見落とす（A は既にマーク済みなので再訪問しない）
4. B が誤って回収される
```

これを<strong>失われた更新問題</strong>と呼びます

この問題を解決するために、トライカラーマーキングとライトバリアが使われます

---

## トライカラーマーキング

### 歴史的背景

Dijkstra と Lamport は、並行 GC のためのトライカラーマーキングを提案しました

オブジェクトを「白」「灰」「黒」の 3 色で管理することで、アプリケーションと並行して GC を実行できます

### 3 つの色

<strong>トライカラーマーキング</strong>は、オブジェクトを 3 つの色で分類する方式です

| 色  | 説明                             |
| --- | -------------------------------- |
| 白  | まだ訪問していない（ゴミの候補） |
| 灰  | 訪問済みだが、子の探索が未完了   |
| 黒  | 訪問済みで、子の探索も完了       |

### 動作

1. 最初、すべてのオブジェクトは白
2. ルートを灰色にする
3. 灰色のオブジェクトを選び、その子を灰色にして、自身を黒にする
4. 灰色がなくなるまで繰り返す
5. 残った白いオブジェクトはゴミ

```
初期状態:
ルート → A(白) → B(白)
         ↓
         C(白)

ステップ 1: ルートを灰色に
ルート → A(灰) → B(白)
         ↓
         C(白)

ステップ 2: A の子を灰色に、A を黒に
ルート → A(黒) → B(灰)
         ↓
         C(灰)

ステップ 3: B の子を処理（なし）、B を黒に
ステップ 4: C の子を処理（なし）、C を黒に

最終状態: すべて黒 → すべて生きている
```

### 不変条件

トライカラーマーキングには<strong>不変条件</strong>があります

<strong>黒いオブジェクトから白いオブジェクトへの直接参照は存在しない</strong>

この不変条件が守られている限り、白いオブジェクトを誤って回収することはありません

並行 GC では、この不変条件を維持するためにライトバリアを使用します

---

## ライトバリア

### ライトバリアとは

<strong>ライトバリア</strong>は、参照の書き込み時に追加の処理を行う仕組みです

アプリケーションがオブジェクトの参照を変更するたびに、GC に通知します

```c
/* ライトバリアなし */
obj->field = new_value;

/* ライトバリアあり（概念的なコード） */
write_barrier(obj, new_value);  /* GC に通知 */
obj->field = new_value;
```

### ライトバリアの種類

<strong>Dijkstra のライトバリア（挿入バリア）</strong>

新しく参照されるオブジェクトを灰色にします

```
A(黒) → B(白) という参照を追加するとき
→ B を灰色にする
```

これにより「黒から白への参照」が生じるのを防ぎます

<strong>Yuasa のライトバリア（削除バリア）</strong>

参照が削除されるオブジェクトを灰色にします

```
A → B という参照を削除するとき（A → C に変更）
→ B を灰色にする
```

参照が切れても、B は次のサイクルまで生き残ります

### ライトバリアのコスト

ライトバリアには、参照書き込みごとにオーバーヘッドがあります

| 方式       | オーバーヘッド | 精度         |
| ---------- | -------------- | ------------ |
| バリアなし | なし           | 並行 GC 不可 |
| 挿入バリア | 中程度         | 良い         |
| 削除バリア | 中程度         | 良い         |

Go の GC は、挿入バリアと削除バリアを組み合わせた<strong>ハイブリッドバリア</strong>を使用しています

---

## 実際の GC 実装

### JVM の G1GC

<strong>G1GC（Garbage First GC）</strong>は、JVM のデフォルト GC です

<strong>特徴</strong>

- ヒープを小さな「リージョン」に分割
- リージョン単位で GC を実行
- 「ゴミが多いリージョン」を優先的に回収（Garbage First の由来）
- 世代別 + 並行 + 増分

```
ヒープ:
[Eden][Eden][Survivor][Old][Old][Old][Humongous]
  ↑                                      ↑
Young 世代のリージョン              大きなオブジェクト用
```

<strong>動作の概要</strong>

1. Young GC: Eden と Survivor のリージョンを回収
2. 並行マーキング: アプリと並行してマークを進める
3. Mixed GC: Young と一部の Old リージョンを回収

### JVM の ZGC

<strong>ZGC</strong>は、超低レイテンシを目指した GC です

<strong>特徴</strong>

- 停止時間は数ミリ秒以下（ヒープサイズに関係なく）
- カラードポインタを使用
- ほぼ完全に並行で動作

<strong>カラードポインタ</strong>

ZGC は、ポインタの一部のビットを GC のメタデータに使用します

```
64 ビットポインタ:
[未使用][マーク][リマップ][ファイナライズ][アドレス（42ビット）]
```

これにより、オブジェクトにアクセスするだけで GC の状態を確認できます

### Go の GC

Go は<strong>並行マーク&スイープ GC</strong>を採用しています

<strong>特徴</strong>

- 世代別ではない（全オブジェクトを毎回走査）
- 非常に短い STW（通常 1ms 以下）
- ハイブリッドライトバリア

<strong>GC サイクル</strong>

1. STW: ライトバリアを有効化
2. 並行マーク: アプリと並行してマークを進める
3. STW: マークを完了、スイープを開始
4. 並行スイープ: アプリと並行して解放

Go の GC は、低レイテンシを最優先に設計されています

スループットは若干犠牲になりますが、Web サーバーなどの用途に適しています

### 比較表

| GC    | 方式                    | 停止時間      | 特徴                   |
| ----- | ----------------------- | ------------- | ---------------------- |
| G1GC  | 世代別 + リージョン     | 数十〜数百 ms | バランス型             |
| ZGC   | 並行 + カラードポインタ | 数 ms 以下    | 超低レイテンシ         |
| Go GC | 並行マーク&スイープ     | 1 ms 以下     | シンプル、低レイテンシ |

---

## 用語集

| 用語                   | 英語                | 説明                                  |
| ---------------------- | ------------------- | ------------------------------------- |
| コピー GC              | Copying GC          | オブジェクトをコピーして回収する方式  |
| Semispace GC           | Semispace GC        | ヒープを 2 分割するコピー GC          |
| 増分 GC                | Incremental GC      | GC を小さな単位に分割して実行         |
| 並行 GC                | Concurrent GC       | アプリと並行して GC を実行            |
| トライカラーマーキング | Tri-color Marking   | 白・灰・黒の 3 色でオブジェクトを分類 |
| ライトバリア           | Write Barrier       | 参照書き込み時の追加処理              |
| 挿入バリア             | Insertion Barrier   | 新しい参照を追加するときのバリア      |
| 削除バリア             | Deletion Barrier    | 参照を削除するときのバリア            |
| リージョン             | Region              | G1GC でのヒープの分割単位             |
| カラードポインタ       | Colored Pointer     | メタデータを含むポインタ（ZGC）       |
| バンプポインタ         | Bump Pointer        | ポインタを進めるだけの高速な割り当て  |
| 失われた更新問題       | Lost Update Problem | 並行 GC で更新が見落とされる問題      |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>GC 理論</strong>

- [The Garbage Collection Handbook](https://gchandbook.org/)
  - GC の包括的な解説書

<strong>JVM</strong>

- [G1 Garbage Collector](https://docs.oracle.com/en/java/javase/21/gctuning/garbage-first-g1-garbage-collector1.html)
  - G1GC の詳細
- [The Z Garbage Collector](https://docs.oracle.com/en/java/javase/21/gctuning/z-garbage-collector.html)
  - ZGC の詳細

<strong>Go</strong>

- [Go GC Guide](https://tip.golang.org/doc/gc-guide)
  - Go の GC 解説
- [Getting to Go: The Journey of Go's Garbage Collector](https://go.dev/blog/ismmkeynote)
  - Go GC の設計思想

<strong>本編との関連</strong>

- [05-gc](../05-gc.md)
  - GC の基本概念
