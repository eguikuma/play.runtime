<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# VM の中はどうなっているのか

## はじめに

[03-vm](../03-vm.md) で、仮想マシンが「バイトコードを実行するソフトウェア」であることを学びました

JVM、CPython VM、V8 といった仮想マシンを比較しましたが、その内部構造までは踏み込みませんでした

このページでは、JVM を代表例として、仮想マシンの内部構造を深掘りします

JVM の仕組みを理解すれば、他の VM の仕組みも理解しやすくなります

### 歴史的背景

JVM は「Write Once, Run Anywhere」を目指して設計されました

Sun Microsystems が Animorphic Systems を買収した後、HotSpot JVM が誕生しました

HotSpot は「ホットスポット」（頻繁に実行されるコード）を検出し、JIT コンパイルする仕組みです

---

## 目次

1. [JVM のアーキテクチャ概要](#jvm-のアーキテクチャ概要)
2. [クラスローダ](#クラスローダ)
3. [ランタイムデータエリア](#ランタイムデータエリア)
4. [実行エンジン](#実行エンジン)
5. [バイトコード検証](#バイトコード検証)
6. [JIT コンパイラの詳細](#jit-コンパイラの詳細)
7. [用語集](#用語集)
8. [参考資料](#参考資料)

---

## JVM のアーキテクチャ概要

JVM は、大きく以下のコンポーネントで構成されています

```
┌─────────────────────────────────────────────────────────┐
│                        JVM                              │
│                                                         │
│  ┌─────────────────┐                                   │
│  │ クラスローダ     │ ← .class ファイルを読み込む       │
│  └────────┬────────┘                                   │
│           ↓                                            │
│  ┌─────────────────────────────────────────────────┐   │
│  │ ランタイムデータエリア                           │   │
│  │  ┌──────────┬──────────┬──────────────────┐    │   │
│  │  │メソッド  │  ヒープ  │  スレッドごとの領域 │    │   │
│  │  │エリア    │          │  ・スタック        │    │   │
│  │  │          │          │  ・PC レジスタ     │    │   │
│  │  └──────────┴──────────┴──────────────────┘    │   │
│  └─────────────────────────────────────────────────┘   │
│           ↓                                            │
│  ┌─────────────────────────────────────────────────┐   │
│  │ 実行エンジン                                     │   │
│  │  ┌──────────────┬──────────────┬────────────┐  │   │
│  │  │インタプリタ   │ JIT コンパイラ │    GC     │  │   │
│  │  └──────────────┴──────────────┴────────────┘  │   │
│  └─────────────────────────────────────────────────┘   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## クラスローダ

### 役割

<strong>クラスローダ</strong>は、.class ファイルを読み込み、JVM 内に展開するコンポーネントです

Java プログラムを実行するとき、最初にクラスローダが動作します

### クラスローダの階層

JVM には、複数のクラスローダが階層的に存在します

| クラスローダ            | 役割                                   |
| ----------------------- | -------------------------------------- |
| Bootstrap ClassLoader   | Java 標準ライブラリを読み込む          |
| Platform ClassLoader    | プラットフォーム固有のクラスを読み込む |
| Application ClassLoader | アプリケーションのクラスを読み込む     |

### 親委譲モデル

クラスの読み込みは、<strong>親委譲モデル</strong>に従います

```
1. クラスの読み込み要求が来る
2. まず親クラスローダに委譲
3. 親が読み込めなければ、自分で読み込む
```

例えば、Application ClassLoader に `MyClass` の読み込み要求が来ると：

1. Platform ClassLoader に委譲
2. Platform ClassLoader は Bootstrap ClassLoader に委譲
3. Bootstrap は標準ライブラリを確認（見つからない）
4. Platform は自分の領域を確認（見つからない）
5. Application が自分の領域から `MyClass` を読み込む

この仕組みにより、標準ライブラリのクラスが上書きされることを防ぎます

### クラスの読み込みプロセス

```
.class ファイル
       ↓
┌──────────────┐
│   読み込み    │ バイト列として読み込む
└──────────────┘
       ↓
┌──────────────┐
│   リンク      │
│  ・検証      │ バイトコードの正当性を確認
│  ・準備      │ static フィールドのメモリ確保
│  ・解決      │ シンボル参照（クラス名などの文字列）を
│              │ メモリアドレスに変換
└──────────────┘
       ↓
┌──────────────┐
│   初期化      │ static ブロックの実行
└──────────────┘
```

---

## ランタイムデータエリア

JVM は、実行時にいくつかのメモリ領域を管理します

### メソッドエリア

<strong>メソッドエリア</strong>は、クラスの構造情報を保存する領域です

| 保存される情報 | 説明                                 |
| -------------- | ------------------------------------ |
| クラス情報     | クラス名、親クラス、インターフェース |
| フィールド情報 | フィールド名、型、アクセス修飾子     |
| メソッド情報   | メソッド名、シグネチャ、バイトコード |
| 定数プール     | リテラル値、シンボル参照             |
| static 変数    | クラス変数                           |

メソッドエリアは、すべてのスレッドで共有されます

### ヒープ

<strong>ヒープ</strong>は、オブジェクトインスタンスを保存する領域です

```java
/*
 * ヒープに確保
 */
Object obj = new Object();
```

ヒープは GC の対象であり、[05-gc](../05-gc.md) で学んだアルゴリズムで管理されます

世代別 GC では、ヒープは以下のように分割されます

```
ヒープ
├── Young 世代
│   ├── Eden
│   ├── Survivor 0
│   └── Survivor 1
└── Old 世代
```

### スタック（JVM スタック）

各スレッドは、専用の<strong>JVM スタック</strong>を持ちます

メソッド呼び出しごとに<strong>フレーム</strong>が積まれます

```
スレッドのスタック
┌──────────────────┐
│ メソッド C のフレーム │ ← スタックトップ
├──────────────────┤
│ メソッド B のフレーム │
├──────────────────┤
│ メソッド A のフレーム │
└──────────────────┘
```

### フレームの構造

各フレームは、以下の情報を持ちます

| 要素               | 説明                                 |
| ------------------ | ------------------------------------ |
| ローカル変数配列   | メソッドのパラメータとローカル変数   |
| オペランドスタック | 計算の中間結果を保持                 |
| フレームデータ     | 定数プールへの参照、例外テーブルなど |

```
フレーム
┌──────────────────────────┐
│ ローカル変数配列          │
│ [0] this                 │
│ [1] arg1                 │
│ [2] localVar             │
├──────────────────────────┤
│ オペランドスタック        │
│ [値1]                    │
│ [値2]                    │
├──────────────────────────┤
│ フレームデータ           │
│  定数プール参照など       │
└──────────────────────────┘
```

### PC レジスタ

各スレッドは、<strong>PC（Program Counter）レジスタ</strong>を持ちます

現在実行中のバイトコード命令のアドレスを保持します

### ネイティブメソッドスタック

JNI を使ってネイティブメソッドを呼び出すとき、別のスタックが使用されます

---

## 実行エンジン

<strong>実行エンジン</strong>は、バイトコードを実際に実行するコンポーネントです

### インタプリタ

<strong>インタプリタ</strong>は、バイトコードを 1 命令ずつ実行します

[03-vm](../03-vm.md) で学んだフェッチ・デコード・実行サイクルを行います

起動は速いですが、同じコードを何度も解釈するオーバーヘッドがあります

### JIT コンパイラ

<strong>JIT コンパイラ</strong>は、頻繁に実行されるコードを機械語にコンパイルします

このような「熱い」コード領域を<strong>ホットスポット</strong>と呼びます（HotSpot JVM の名前の由来）

コンパイル後は、インタプリタを介さず直接実行されます

### GC

<strong>GC</strong>は、不要になったオブジェクトを回収します

[05-gc](../05-gc.md) と [gc-algorithms](./gc-algorithms.md) で詳しく説明しています

---

## バイトコード検証

### なぜ検証が必要か

JVM は、信頼できないソースからのバイトコードも実行する可能性があります

悪意のあるバイトコードがシステムを攻撃することを防ぐため、検証が必要です

### 検証の内容

| 検証項目                 | 説明                             |
| ------------------------ | -------------------------------- |
| 型の整合性               | オペランドスタックの型が正しいか |
| スタックのオーバーフロー | スタックが溢れないか             |
| ローカル変数のアクセス   | 範囲外アクセスがないか           |
| final の遵守             | final クラスを継承していないか   |

### 検証の例

```
バイトコード:
  /*
   * int 1 をスタックに積む
   */
  iconst_1
  /*
   * スタックから int を取り出し、ローカル変数 0 に格納
   */
  istore_0
  /*
   * ローカル変数 0 を参照としてスタックに積む（エラー！）
   */
  aload_0
```

この例では、`istore_0` で int を格納した後、`aload_0` で参照として読もうとしています

検証器はこれを検出し、エラーを報告します

---

## JIT コンパイラの詳細

### 階層コンパイル

HotSpot JVM は、<strong>階層コンパイル（Tiered Compilation）</strong>を採用しています

実行回数に応じて、段階的に最適化レベルを上げていきます

| レベル | 実行方式                     | 説明                         |
| ------ | ---------------------------- | ---------------------------- |
| 0      | インタプリタ                 | バイトコードを解釈実行       |
| 1      | C1（プロファイリングなし）   | 軽い最適化、起動重視         |
| 2      | C1（限定的プロファイリング） | 呼び出し回数などを収集       |
| 3      | C1（完全プロファイリング）   | 詳細な実行情報を収集         |
| 4      | C2                           | 収集した情報を元に重い最適化 |

一般的な流れは、レベル 0 → レベル 3 → レベル 4 です

最初は高速に起動し、時間をかけて最適化を進める戦略です

### C1 と C2 コンパイラ

| コンパイラ   | 特徴                                 |
| ------------ | ------------------------------------ |
| C1（Client） | コンパイルが速い、軽い最適化         |
| C2（Server） | コンパイルに時間がかかる、重い最適化 |

### JIT の最適化技術

JIT コンパイラは、様々な最適化を行います

<strong>インライン化</strong>

小さなメソッドを呼び出し元に展開

```java
/*
 * 最適化前
 */
int result = add(1, 2);

/*
 * 最適化後
 * add メソッドが展開される
 */
int result = 1 + 2;
```

<strong>デッドコード除去</strong>

実行されないコードを削除

<strong>ループ最適化</strong>

ループの効率を改善（アンローリング、ベクトル化など）

<strong>脱最適化（Deoptimization）</strong>

最適化の前提が崩れた場合、インタプリタに戻る

```java
void method(Animal a) {
    /*
     * Animal が Dog だけだと仮定して最適化
     */
    a.speak();
}

/*
 * 後から Cat が渡されると、最適化が無効になる
 * 脱最適化が発生
 */
method(new Cat());
```

JIT コンパイラは、「今まで Dog しか渡されていない」という実行履歴を見て、`Dog.speak()` を直接呼び出すコードを生成します

しかし `Cat` が渡されると、この仮定が崩れるため、汎用的なコードに戻す必要があります

---

## 用語集

| 用語               | 英語                    | 説明                                     |
| ------------------ | ----------------------- | ---------------------------------------- |
| クラスローダ       | ClassLoader             | .class ファイルを読み込むコンポーネント  |
| 親委譲モデル       | Parent Delegation Model | 親クラスローダに先に委譲する仕組み       |
| メソッドエリア     | Method Area             | クラス情報を保存する領域                 |
| 定数プール         | Constant Pool           | リテラルやシンボル参照を保存             |
| JVM スタック       | JVM Stack               | メソッド呼び出しのスタック               |
| フレーム           | Frame                   | メソッド呼び出しごとの情報               |
| オペランドスタック | Operand Stack           | 計算の中間結果を保持するスタック         |
| PC レジスタ        | PC Register             | 現在の命令位置を保持                     |
| 階層コンパイル     | Tiered Compilation      | 段階的に最適化を進める方式               |
| C1 コンパイラ      | C1 Compiler             | 軽い最適化を行う JIT                     |
| C2 コンパイラ      | C2 Compiler             | 重い最適化を行う JIT                     |
| 脱最適化           | Deoptimization          | 最適化を取り消してインタプリタに戻ること |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>JVM 仕様</strong>

- [The Java Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se21/html/index.html)
  - JVM の公式仕様

<strong>HotSpot</strong>

- [HotSpot Runtime Overview](https://openjdk.org/groups/hotspot/docs/RuntimeOverview.html)
  - HotSpot の内部構造

<strong>JIT コンパイラ</strong>

- [Introduction to Graal and JIT Compilation](https://www.graalvm.org/latest/docs/introduction/)
  - JIT コンパイラの概要

<strong>本編との関連</strong>

- [03-vm](../03-vm.md)
  - 仮想マシンの基本
- [05-gc](../05-gc.md)
  - ガベージコレクション
