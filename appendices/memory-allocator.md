<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# malloc/free はどうやってメモリを管理するのか

## はじめに

[04-stack-heap](../04-stack-heap.md) で、ヒープは `malloc()` で確保し `free()` で解放することを学びました

```c
int *p = malloc(sizeof(int) * 100);  /* ヒープから 400 バイト確保 */
/* ... pを使用 ... */
free(p);  /* 明示的に解放 */
```

しかし、malloc と free の内部では何が起きているのでしょうか？

OS はメモリをページ単位（通常 4KB）で管理しています

malloc は、この大きなページを小さなチャンクに分割して提供しています

このページでは、メモリアロケータの「中身」を深掘りします

---

## 目次

1. [malloc の役割](#malloc-の役割)
2. [フリーリスト](#フリーリスト)
3. [チャンクの構造](#チャンクの構造)
4. [フラグメンテーション](#フラグメンテーション)
5. [サイズクラス](#サイズクラス)
6. [アリーナとスレッド対応](#アリーナとスレッド対応)
7. [OS からのメモリ取得](#os-からのメモリ取得)
8. [主要なアロケータ](#主要なアロケータ)
9. [用語集](#用語集)
10. [参考資料](#参考資料)

---

## malloc の役割

### なぜ malloc が必要か

OS に直接メモリを要求することもできます

Linux では `mmap` や `brk` システムコールでメモリを確保できます

しかし、OS はメモリをページ単位（通常 4KB）で管理しています

100 バイトを確保するために 4KB を要求するのは無駄です

malloc は、OS から大きなメモリを取得し、小さく分割してプログラムに提供します

### malloc の責務

| 責務   | 説明                                   |
| ------ | -------------------------------------- |
| 分割   | 大きなメモリを小さなチャンクに分割     |
| 追跡   | どこが使用中で、どこが空きかを管理     |
| 再利用 | 解放されたメモリを次の malloc で再利用 |
| 効率化 | フラグメンテーションを最小限に抑える   |

---

## フリーリスト

### 基本的なアイデア

最もシンプルなメモリ管理は<strong>フリーリスト</strong>（空きメモリブロックのリスト）です

解放されたメモリブロックを、リンクリストでつないで管理します

```
フリーリスト（最初は1つの大きなブロック）

┌────────────────────────────────────────┐
│ 空きブロック（1000バイト）              │
│ next → NULL                           │
└────────────────────────────────────────┘

malloc(100) を呼ぶと...

┌──────────────┬─────────────────────────┐
│ 使用中(100)  │ 空き（残り）            │
│              │ next → NULL             │
└──────────────┴─────────────────────────┘
```

### free の動作

free で解放すると、そのブロックがフリーリストに戻ります

```
free(p) を呼ぶと...

┌──────────────┬─────────────────────────┐
│ 空き（100）  │ 空き（残り）            │
│ next ────────┼→                       │
└──────────────┴─────────────────────────┘
```

隣接する空きブロックは<strong>結合（coalesce）</strong>して大きなブロックにできます

### フリーリストの問題点

シンプルなフリーリストには問題があります

- <strong>検索が遅い</strong>：適切なサイズのブロックを見つけるのに O(n) かかる
- <strong>フラグメンテーション</strong>：小さな空きブロックが散らばる
- <strong>マルチスレッド</strong>：複数スレッドからのアクセスでロック競合が発生

これらを解決するため、実際のアロケータはより複雑な仕組みを使います

---

## チャンクの構造

### メタデータの必要性

malloc で確保したメモリには、<strong>メタデータ</strong>が付随しています

free を呼ぶとき、サイズを指定しません

```c
free(p);  /* サイズを指定しない */
```

アロケータは、ポインタからサイズを知る必要があります

そのため、確保したメモリの直前にメタデータを置きます

### glibc malloc のチャンク構造

glibc の malloc では、チャンクは以下のような構造を持ちます

```
┌────────────────────┐
│ prev_size (8バイト) │ ← 直前のチャンクが空きの場合のサイズ
├────────────────────┤
│ size | flags       │ ← チャンクのサイズとフラグ
├────────────────────┤ ← malloc が返すポインタはここ
│                    │
│ ユーザーデータ      │
│                    │
├────────────────────┤
│（次のチャンク）     │
└────────────────────┘
```

size フィールドの下位 3 ビットはフラグとして使われます

- <strong>PREV_INUSE</strong>：直前のチャンクが使用中か
- <strong>IS_MMAPPED</strong>：mmap で確保されたか
- <strong>NON_MAIN_ARENA</strong>：メインアリーナ以外か

これらのフラグにより、アロケータはチャンクの状態を効率的に判断できます

### なぜポインタの前にメタデータを置くか

ユーザーが使うメモリの直前にメタデータを置くことで、ポインタからメタデータにアクセスできます

```c
/* 内部的なイメージ */
struct chunk {
    size_t prev_size;
    size_t size;
    char data[];  /* 可変長配列 */
};

void free(void *ptr) {
    /* ポインタから chunk 構造体の先頭を計算 */
    struct chunk *c = (struct chunk *)((char *)ptr - 16);
    size_t size = c->size & ~0x7;  /* フラグを除いたサイズ */
    /* ... */
}
```

---

## フラグメンテーション

### 2 種類のフラグメンテーション

<strong>外部フラグメンテーション（External Fragmentation）</strong>

空きメモリの合計は十分だが、連続した領域がないため確保できない状態

```
要求: 400 バイトの連続領域

メモリ状態:
[使用100][空き200][使用100][空き300][使用100][空き200]

合計空き: 700 バイト
連続した最大空き: 300 バイト
→ 400 バイトは確保できない
```

<strong>内部フラグメンテーション（Internal Fragmentation）</strong>

確保したブロック内に、使われない領域がある状態

```
要求: 100 バイト
確保: 128 バイト（アライメントのため）

[使用100][無駄28]

→ 28 バイトが内部フラグメンテーション
```

### フラグメンテーションへの対策

| 対策               | 説明                                |
| ------------------ | ----------------------------------- |
| 結合（coalescing） | 隣接する空きブロックを結合          |
| サイズクラス       | 似たサイズをまとめて管理            |
| コンパクション     | メモリを移動して詰める（GC が必要） |

---

## サイズクラス

### サイズに応じた管理

実際のアロケータは、サイズごとに異なる戦略を使います

glibc malloc では、サイズに応じて以下のカテゴリに分けます

| カテゴリ | サイズ範囲             | 管理方法                   |
| -------- | ---------------------- | -------------------------- |
| fastbin  | 〜128 バイト程度       | LIFO リスト（高速）        |
| smallbin | 〜1024 バイト未満      | サイズ別の双方向リスト     |
| largebin | 1024 バイト〜          | サイズでソートされたリスト |
| mmap     | 閾値以上（128KB 程度） | OS に直接 mmap             |

### fastbin

小さなチャンクは、頻繁に確保・解放されます

fastbin は、解放されたチャンクを結合せず、LIFO（後入れ先出し）で管理します

```
fastbin[32] → [chunk] → [chunk] → [chunk] → NULL
fastbin[48] → [chunk] → [chunk] → NULL
fastbin[64] → [chunk] → NULL
```

次の malloc で同じサイズが要求されたら、リストの先頭からすぐに返せます

結合しないため、外部フラグメンテーションは増えますが、速度を優先しています

### largebin と mmap

大きなメモリは、smallbin/fastbin とは別に管理されます

非常に大きなメモリ（通常 128KB 以上）は、OS に直接 `mmap` を呼んで確保します

mmap で確保されたメモリは、free で `munmap` して OS に返します

---

## アリーナとスレッド対応

### マルチスレッドの問題

複数のスレッドが同時に malloc を呼ぶと、フリーリストへのアクセスで競合が発生します

単純にロックすると、性能が大幅に低下します

### アリーナ

glibc malloc は<strong>アリーナ</strong>という仕組みでこの問題に対処しています

アリーナは、独立したヒープ領域とフリーリストのセットです

```
メインアリーナ（最初のスレッド用）
┌─────────────────┐
│ ヒープ領域      │
│ フリーリスト    │
│ ロック         │
└─────────────────┘

アリーナ 2（別スレッド用）
┌─────────────────┐
│ ヒープ領域      │
│ フリーリスト    │
│ ロック         │
└─────────────────┘
```

各スレッドは、できるだけ自分専用のアリーナを使います

異なるアリーナへのアクセスは、ロック競合が発生しません

### アリーナの数

glibc malloc では、アリーナの数は CPU コア数に基づいて決まります

32 ビット環境では最大 2 × コア数、64 ビット環境では最大 8 × コア数です

---

## OS からのメモリ取得

### brk と mmap

malloc は、OS から 2 つの方法でメモリを取得します

<strong>brk（sbrk）</strong>

プログラムの「ヒープ領域」を拡張します

プロセスのデータセグメントの終端（program break）を移動させます

```
メモリレイアウト

[テキスト][データ][BSS][ヒープ ←→ ][スタック]
                        ↑
                    program break
```

brk は連続したメモリを提供しますが、縮小が難しい欠点があります

<strong>mmap</strong>

新しい仮想メモリ領域を作成します

大きなメモリや、独立した領域が必要な場合に使われます

```c
void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
```

mmap で確保したメモリは、munmap で完全に OS に返せます

### 使い分け

| 方法 | 用途         | メリット                   | デメリット       |
| ---- | ------------ | -------------------------- | ---------------- |
| brk  | 小〜中サイズ | 連続領域、オーバーヘッド小 | 縮小が難しい     |
| mmap | 大きいサイズ | 完全に返却可能             | オーバーヘッド大 |

glibc malloc は、閾値（MMAP_THRESHOLD、デフォルト 128KB）以上で mmap を使います

---

## 主要なアロケータ

### 歴史的背景：dlmalloc

Doug Lea は、汎用的なメモリアロケータ dlmalloc を開発しました

dlmalloc は多くの言語・ライブラリに影響を与え、glibc の malloc 実装の基礎にもなりました

### glibc malloc（ptmalloc2）

Linux のデフォルトアロケータです

- Doug Lea の dlmalloc をベースに、マルチスレッド対応を追加
- アリーナによるスレッド対応
- fastbin/smallbin/largebin によるサイズ別管理

### jemalloc

FreeBSD のデフォルトであり、Firefox や Redis で使用されています

- スレッドキャッシュ（tcache）でロック競合を削減
- サイズクラスの細かい分割
- フラグメンテーションの削減に注力

### tcmalloc（Thread-Caching Malloc）

Google が開発したアロケータです

- 各スレッドにローカルキャッシュを持つ
- 小さなオブジェクトはほぼロックフリー
- Chrome や MySQL で使用

### mimalloc

Microsoft が開発した高性能アロケータです

- 非常に高いスレッドスケーラビリティ
- ページ単位の管理
- 比較的新しい

### 比較

| アロケータ   | 特徴                     | 用途                 |
| ------------ | ------------------------ | -------------------- |
| glibc malloc | 汎用、Linux デフォルト   | 一般的な用途         |
| jemalloc     | フラグメンテーション削減 | 長時間稼働サーバー   |
| tcmalloc     | 高スレッド性能           | マルチスレッドアプリ |
| mimalloc     | 最新の高性能             | 性能重視のアプリ     |

---

## 用語集

| 用語                     | 英語                   | 説明                                     |
| ------------------------ | ---------------------- | ---------------------------------------- |
| メモリアロケータ         | Memory Allocator       | メモリの確保・解放を管理するライブラリ   |
| フリーリスト             | Free List              | 空きメモリブロックのリスト               |
| チャンク                 | Chunk                  | アロケータが管理するメモリの単位         |
| メタデータ               | Metadata               | チャンクに付随する管理情報               |
| 外部フラグメンテーション | External Fragmentation | 空きが分散して大きな確保ができない状態   |
| 内部フラグメンテーション | Internal Fragmentation | 確保したブロック内の無駄な領域           |
| 結合                     | Coalescing             | 隣接する空きブロックを合わせること       |
| サイズクラス             | Size Class             | 似たサイズをまとめた分類                 |
| アリーナ                 | Arena                  | 独立したヒープ領域とフリーリストのセット |
| fastbin                  | Fastbin                | 小さなチャンク用の高速リスト             |
| program break            | Program Break          | ヒープ領域の終端                         |
| brk                      | brk                    | ヒープを拡張するシステムコール           |
| mmap                     | mmap                   | メモリ領域をマッピングするシステムコール |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>glibc malloc</strong>

- [MallocInternals - glibc wiki](https://sourceware.org/glibc/wiki/MallocInternals)
  - glibc malloc の内部構造

<strong>jemalloc</strong>

- [jemalloc](https://jemalloc.net/)
  - jemalloc の公式サイト

<strong>tcmalloc</strong>

- [TCMalloc Overview](https://google.github.io/tcmalloc/overview.html)
  - Google の tcmalloc ドキュメント

<strong>mimalloc</strong>

- [mimalloc](https://microsoft.github.io/mimalloc/)
  - Microsoft の mimalloc

<strong>システムコール</strong>

- [brk(2) - Linux manual page](https://man7.org/linux/man-pages/man2/brk.2.html)
  - brk/sbrk システムコール
- [mmap(2) - Linux manual page](https://man7.org/linux/man-pages/man2/mmap.2.html)
  - mmap システムコール

<strong>本編との関連</strong>

- [04-stack-heap](../04-stack-heap.md)
  - ヒープとスタックの基本
