<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# なぜ関数呼び出しに「規約」が必要なのか

## はじめに

[04-stack-heap](../04-stack-heap.md) で、関数呼び出しのたびに<strong>スタックフレーム</strong>が積まれることを学びました

[07-ffi](../07-ffi.md) では、<strong>ABI（Application Binary Interface）</strong>の一部として<strong>呼び出し規約</strong>があることを学びました

呼び出し規約とは、「引数をどう渡すか」「戻り値をどう受け取るか」のルールです

07-ffi では System V AMD64 ABI のレジスタ表を紹介しましたが、この規約にはさらに詳しい内容があります

このページでは、呼び出し規約の「なぜ」と「どうやって」を深掘りします

---

## 目次

1. [なぜ呼び出し規約が必要か](#なぜ呼び出し規約が必要か)
2. [呼び出し規約の構成要素](#呼び出し規約の構成要素)
3. [System V AMD64 ABI 詳細](#system-v-amd64-abi-詳細)
4. [Windows x64 との違い](#windows-x64-との違い)
5. [ARM64 の呼び出し規約](#arm64-の呼び出し規約)
6. [スタックフレームの構造](#スタックフレームの構造)
7. [レジスタの保存責任](#レジスタの保存責任)
8. [用語集](#用語集)
9. [参考資料](#参考資料)

---

## なぜ呼び出し規約が必要か

### 異なるコードが連携するため

関数呼び出しは、単に「別の場所にジャンプする」だけではありません

呼び出し元（caller）と呼び出し先（callee）が、以下について合意している必要があります

- 引数はどこに置くか（レジスタ？スタック？）
- 戻り値はどこに置くか
- どのレジスタは自由に使ってよいか
- スタックはどう使うか

これらのルールが「呼び出し規約」です

### 規約がないと何が起きるか

想像してみてください

ライブラリ A は「第一引数を RDI レジスタに置く」と決めています

ライブラリ B は「第一引数を RAX レジスタに置く」と決めています

この 2 つのライブラリは連携できません

呼び出し規約があれば、異なるコンパイラで作られたコード同士も連携できます

---

## 呼び出し規約の構成要素

呼び出し規約は、以下の要素で構成されます

| 要素               | 説明                                |
| ------------------ | ----------------------------------- |
| 引数の渡し方       | レジスタとスタックの使い分け        |
| 戻り値の渡し方     | どのレジスタに格納するか            |
| レジスタの保存責任 | caller-saved と callee-saved の区別 |
| スタックの使い方   | アライメント、レッドゾーンなど      |

---

## System V AMD64 ABI 詳細

Linux と macOS で使われる呼び出し規約です

### 歴史的背景

UNIX System V が策定された頃、呼び出し規約も標準化されました

これが<strong>System V ABI</strong>です

一方、Windows は独自の呼び出し規約を採用しました

両者は引数の渡し方、レジスタの使い方が異なります

### 引数の渡し方

整数・ポインタ引数は、以下のレジスタで渡します

| 引数の順番 | 格納先   |
| ---------- | -------- |
| 1 番目     | RDI      |
| 2 番目     | RSI      |
| 3 番目     | RDX      |
| 4 番目     | RCX      |
| 5 番目     | R8       |
| 6 番目     | R9       |
| 7 番目以降 | スタック |

浮動小数点引数は XMM0〜XMM7 で渡します

### 戻り値の渡し方

| 型             | 格納先                           |
| -------------- | -------------------------------- |
| 整数・ポインタ | RAX（大きい場合は RAX + RDX）    |
| 浮動小数点     | XMM0（大きい場合は XMM0 + XMM1） |

### 具体例

以下の関数呼び出しを考えます

```c
int add(int a, int b, int c) {
    return a + b + c;
}

int main() {
    int result = add(1, 2, 3);
    return 0;
}
```

コンパイラがこのコードを機械語に変換すると、以下のようになります

```
main:
    mov edi, 1      ; 第一引数 → RDI（下位32ビット = EDI）
    mov esi, 2      ; 第二引数 → RSI（下位32ビット = ESI）
    mov edx, 3      ; 第三引数 → RDX（下位32ビット = EDX）
    call add
    ; 戻り値は RAX（下位32ビット = EAX）に入っている

add:
    ; edi = 1, esi = 2, edx = 3
    add edi, esi    ; edi = 1 + 2 = 3
    add edi, edx    ; edi = 3 + 3 = 6
    mov eax, edi    ; 戻り値を EAX に
    ret
```

### スタックアライメント

関数呼び出し時、RSP（スタックポインタ）は 16 バイト境界に揃っている必要があります

`call` 命令は戻りアドレス（8 バイト、64 ビットアドレス 1 つ分）をプッシュするため、関数の先頭では RSP は 16 バイト境界から 8 バイトずれています

多くの関数は、プロローグで調整を行います

```
func:
    push rbp        ; 8 バイトプッシュ → 16 バイト境界に戻る
    mov rbp, rsp
    ...
```

### レッドゾーン

System V AMD64 ABI では、RSP より下の 128 バイトは<strong>レッドゾーン</strong>として予約されています

関数は、この領域を「一時的なデータ置き場」として使えます

シグナルハンドラや割り込みは、この領域を破壊しません

```
┌──────────────┐ 高いアドレス
│ スタック内容  │
├──────────────┤ ← RSP
│              │
│ レッドゾーン  │ 128 バイト
│（使用可能）  │
│              │
├──────────────┤ ← RSP - 128
│              │ 低いアドレス
```

葉関数（他の関数を呼ばない関数）は、レッドゾーンだけを使うことでスタック調整を省略できます

---

## Windows x64 との違い

Windows は独自の x64 呼び出し規約を使用します

### 引数の渡し方

| 引数の順番 | 整数・ポインタ | 浮動小数点 |
| ---------- | -------------- | ---------- |
| 1 番目     | RCX            | XMM0       |
| 2 番目     | RDX            | XMM1       |
| 3 番目     | R8             | XMM2       |
| 4 番目     | R9             | XMM3       |
| 5 番目以降 | スタック       | スタック   |

System V と異なり、最初の 4 つの引数のみがレジスタで渡されます

### シャドウスペース

Windows x64 では、呼び出し元が最初の 4 つの引数用に 32 バイトの<strong>シャドウスペース</strong>をスタック上に確保する必要があります

```
┌──────────────┐
│ 5番目以降の引数 │
├──────────────┤
│ シャドウ（R9用）│ 8 バイト
├──────────────┤
│ シャドウ（R8用）│ 8 バイト
├──────────────┤
│ シャドウ（RDX用）│ 8 バイト
├──────────────┤
│ シャドウ（RCX用）│ 8 バイト
├──────────────┤ ← RSP（call 直前）
│ 戻りアドレス   │
└──────────────┘
```

シャドウスペースは、呼び出し先がレジスタの引数をスタックに退避するために使えます

また、可変長引数関数で便利です

### レッドゾーンがない

Windows x64 にはレッドゾーンがありません

RSP より下の領域は、いつでも破壊される可能性があります

### 比較表

| 要素             | System V AMD64             | Windows x64   |
| ---------------- | -------------------------- | ------------- |
| レジスタ引数の数 | 6（整数）+ 8（浮動小数点） | 4（共用）     |
| 整数の第一引数   | RDI                        | RCX           |
| シャドウスペース | なし                       | 32 バイト必須 |
| レッドゾーン     | 128 バイト                 | なし          |

---

## ARM64 の呼び出し規約

ARM64（AArch64）は、x86-64 とは異なるアーキテクチャですが、呼び出し規約の考え方は共通しています

### 引数の渡し方

| 引数の順番 | 整数・ポインタ | 浮動小数点 |
| ---------- | -------------- | ---------- |
| 1〜8 番目  | X0〜X7         | V0〜V7     |
| 9 番目以降 | スタック       | スタック   |

ARM64 では、8 つの引数までレジスタで渡せます

### 戻り値

| 型             | 格納先                     |
| -------------- | -------------------------- |
| 整数・ポインタ | X0（大きい場合は X0 + X1） |
| 浮動小数点     | V0                         |

### 特徴

ARM64 の呼び出し規約には以下の特徴があります

- <strong>リンクレジスタ</strong>（X30/LR）に戻りアドレスを格納
- x86 のように `call` がスタックにプッシュしない
- 16 バイトのスタックアライメント

```
; ARM64 の関数呼び出し
bl func         ; Branch with Link: LR に戻りアドレスを格納し、func へジャンプ

; func 内で戻るとき
ret             ; LR のアドレスへジャンプ
```

---

## スタックフレームの構造

[04-stack-heap](../04-stack-heap.md) で、スタックフレームには「戻りアドレス」「ローカル変数」などが含まれると学びました

ここでは、System V AMD64 ABI でのスタックフレームの詳細な構造を見ます

### 典型的なスタックフレーム

```
┌──────────────────┐ 高いアドレス
│ 呼び出し元のフレーム │
├──────────────────┤
│ 引数（7番目以降）  │ ← 呼び出し元が配置
├──────────────────┤
│ 戻りアドレス       │ ← call 命令が配置
├──────────────────┤
│ 保存された RBP    │ ← push rbp
├──────────────────┤ ← RBP（フレームポインタ）
│ ローカル変数      │
│ ...             │
├──────────────────┤
│ 保存されたレジスタ │ ← callee-saved レジスタの退避
├──────────────────┤ ← RSP（スタックポインタ）
│（レッドゾーン）    │ 128 バイト
└──────────────────┘ 低いアドレス
```

### フレームポインタ（RBP）

RBP は、現在のスタックフレームの「基準点」として使われます

- RBP + 8 → 戻りアドレス
- RBP + 16 → 7 番目の引数（あれば）
- RBP - 8 → 最初のローカル変数

フレームポインタを使うと、スタック上のデータに固定のオフセットでアクセスできます

### フレームポインタの省略

最適化が有効な場合、コンパイラはフレームポインタを省略することがあります

この場合、RSP からの相対アドレスでローカル変数にアクセスします

省略のメリットは、RBP を汎用レジスタとして使えることです

省略のデメリットは、デバッグやスタックトレースが難しくなることです

GCC では `-fomit-frame-pointer` で制御できます

---

## レジスタの保存責任

関数呼び出しでは、レジスタの値が破壊される可能性があります

どのレジスタを誰が保存するかも、呼び出し規約で決まっています

### caller-saved レジスタ

<strong>呼び出し元</strong>が保存する責任を持つレジスタです

呼び出し先は、これらのレジスタを自由に使えます

System V AMD64 ABI では

- RAX、RCX、RDX、RSI、RDI、R8〜R11
- XMM0〜XMM15

これらは「揮発性（volatile）」とも呼ばれます

### callee-saved レジスタ

<strong>呼び出し先</strong>が保存する責任を持つレジスタです

呼び出し先がこれらを使う場合、元の値を保存し、戻る前に復元する必要があります

System V AMD64 ABI では

- RBX、RBP、R12〜R15

これらは「不揮発性（non-volatile）」とも呼ばれます

### 具体例

```c
int caller() {
    /*
     * R12 を使っている
     */
    int x = some_value_in_r12;
    /*
     * callee を呼ぶ
     */
    int y = callee();
    /*
     * R12 は変わっていないはず
     */
    return x + y;
}

int callee() {
    /*
     * R12 を使いたい場合
     */
    /*
     * 元の値を保存
     */
    push r12
    /*
     * 使用
     */
    mov r12, 100
    ...
    /*
     * 復元
     */
    pop r12
    ret
}
```

callee が R12 を使っても、caller の変数 x は安全です

---

## 用語集

| 用語             | 英語                         | 説明                                  |
| ---------------- | ---------------------------- | ------------------------------------- |
| 呼び出し規約     | Calling Convention           | 関数呼び出しのルール                  |
| ABI              | Application Binary Interface | バイナリレベルの互換性仕様            |
| caller           | Caller                       | 関数を呼び出す側                      |
| callee           | Callee                       | 呼び出される関数                      |
| caller-saved     | Caller-saved                 | 呼び出し元が保存責任を持つレジスタ    |
| callee-saved     | Callee-saved                 | 呼び出し先が保存責任を持つレジスタ    |
| フレームポインタ | Frame Pointer                | スタックフレームの基準となるレジスタ  |
| スタックポインタ | Stack Pointer                | スタックの先頭を指すレジスタ          |
| レッドゾーン     | Red Zone                     | RSP 下の予約領域（System V）          |
| シャドウスペース | Shadow Space                 | 引数退避用の領域（Windows）           |
| リンクレジスタ   | Link Register                | 戻りアドレスを格納するレジスタ（ARM） |
| 葉関数           | Leaf Function                | 他の関数を呼ばない関数                |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>System V AMD64 ABI</strong>

- [System V Application Binary Interface - AMD64 Architecture Processor Supplement](https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf)
  - Linux/macOS の x86-64 呼び出し規約

<strong>Windows x64</strong>

- [x64 calling convention - Microsoft Learn](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention)
  - Windows の x64 呼び出し規約

<strong>ARM64</strong>

- [Procedure Call Standard for the Arm 64-bit Architecture](https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst)
  - ARM64 の呼び出し規約

<strong>本編との関連</strong>

- [04-stack-heap](../04-stack-heap.md)
  - スタックフレームの基本
- [07-ffi](../07-ffi.md)
  - ABI と FFI の概要
