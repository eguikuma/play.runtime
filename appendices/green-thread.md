<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# なぜ OS スレッドとは別の「軽量スレッド」が必要なのか

## はじめに

[06-concurrency](../06-concurrency.md) で、<strong>軽量スレッド（グリーンスレッド）</strong>と <strong>M:N スケジューリング</strong>を学びました

Go の goroutine は数十万個作っても問題ないと説明しました

しかし、なぜそのようなことが可能なのでしょうか？

このページでは、軽量スレッドの一般的な概念と、複数の言語での実装を深掘りします

### 名前の由来

「グリーンスレッド」という名前は、Java の前身である Green プロジェクトに由来します

Green プロジェクトでは、OS のスレッドではなく、VM が管理するスレッドを使っていました

---

## 目次

1. [軽量スレッドの必要性](#軽量スレッドの必要性)
2. [軽量スレッドの仕組み](#軽量スレッドの仕組み)
3. [スタック管理](#スタック管理)
4. [スケジューラの実装](#スケジューラの実装)
5. [ブロッキング操作の扱い](#ブロッキング操作の扱い)
6. [各言語の軽量スレッド](#各言語の軽量スレッド)
7. [用語集](#用語集)
8. [参考資料](#参考資料)

---

## 軽量スレッドの必要性

### OS スレッドの限界

[06-concurrency](../06-concurrency.md) で学んだように、OS スレッドには以下の限界があります

| 問題           | 詳細                                     |
| -------------- | ---------------------------------------- |
| メモリ消費     | 1 スレッドあたり 1〜8MB のスタック       |
| 生成コスト     | スレッド生成は数十〜数百マイクロ秒       |
| 切り替えコスト | コンテキストスイッチにカーネル介入が必要 |

1 万個の同時接続を処理する Web サーバーで、接続ごとに OS スレッドを作ると、スタックだけで 10GB 以上のメモリが必要になります

### C10K 問題

<strong>C10K 問題</strong>は、1 台のサーバーで 1 万（10K）クライアントを同時に処理する課題です

Dan Kegel が提唱した問題です

当時の典型的なアプローチ（1 接続 = 1 スレッド）では、この規模をスケールできませんでした

### 解決策としての軽量スレッド

軽量スレッドは、この問題を解決するアプローチの一つです

| 比較項目             | OS スレッド | 軽量スレッド |
| -------------------- | ----------- | ------------ |
| 1万個のメモリ        | 10〜80GB    | 数十〜数百MB |
| 生成速度             | 遅い        | 高速         |
| コンテキストスイッチ | 重い        | 軽い         |

---

## 軽量スレッドの仕組み

### ユーザー空間での管理

軽量スレッドは、OS ではなくランタイムが管理します

OS から見ると、アプリケーションは通常のプロセスとして動いています

その中で、ランタイムが独自にスレッドをスケジューリングしています

```
┌─────────────────────────────────────────┐
│ プロセス                                │
│                                         │
│ ┌──────────────────────────────────┐   │
│ │ ランタイム                        │   │
│ │                                   │   │
│ │  G1  G2  G3  G4  G5  （軽量スレッド）│ │
│ │   ↓   ↓   ↓   ↓   ↓              │   │
│ │  ランタイムスケジューラ            │   │
│ │   ↓         ↓         ↓          │   │
│ │  T1        T2        T3 （OS スレッド） │
│ └──────────────────────────────────┘   │
│                                         │
└─────────────────────────────────────────┘
```

### 必要な要素

軽量スレッドを実現するには、以下の要素が必要です

| 要素           | 説明                                    |
| -------------- | --------------------------------------- |
| 軽量なスタック | OS スレッドより小さいスタック           |
| スケジューラ   | 軽量スレッドを OS スレッドに割り当てる  |
| 切り替え機構   | 軽量スレッド間のコンテキストスイッチ    |
| I/O 統合       | ブロッキング I/O を非ブロッキングに変換 |

---

## スタック管理

### 固定スタック vs 可変スタック

OS スレッドは、通常 1〜8MB の固定サイズのスタックを持ちます

軽量スレッドは、より小さなスタックを使います

| 方式           | 説明               | 採用言語       |
| -------------- | ------------------ | -------------- |
| 固定小スタック | 小さな固定サイズ   | 一部の実装     |
| 可変スタック   | 必要に応じて拡張   | Go、Erlang     |
| スタックレス   | スタックを持たない | Python asyncio |

### Go のスタック成長

Go の goroutine は、最初は小さなスタック（数 KB）で開始します

スタックが足りなくなると、自動的に拡張されます

```
1. goroutine 開始: スタック = 数 KB
2. 関数呼び出しでスタックが足りなくなる
3. ランタイムが新しい大きなスタックを確保
4. 古いスタックの内容をコピー
5. 古いスタックを解放
6. 実行を継続
```

この仕組みを<strong>スタックコピー</strong>と呼びます

### セグメント化スタック

Go の古いバージョンでは、<strong>セグメント化スタック</strong>を使っていました

スタックを複数のセグメントに分割し、必要に応じて追加する方式です

しかし、スタックの境界を頻繁に跨ぐと性能が低下する問題（<strong>ホットスプリット</strong>）があり、スタックコピー方式に変更されました

---

## スケジューラの実装

### Go の GMP モデル詳細

[06-concurrency](../06-concurrency.md) で紹介した GMP モデルをより詳しく見ます

```
G（Goroutine）
├── スタック（数 KB〜）
├── 命令ポインタ
├── 状態（実行中、待機中、実行可能など）
└── その他のコンテキスト

P（Processor）
├── ローカルキュー（実行可能な G のリスト）
├── mcache（メモリアロケータのキャッシュ）
└── 現在実行中の G

M（Machine）
├── OS スレッド
├── 現在の P
└── スケジューラ用のコンテキスト
```

### ローカルキューとグローバルキュー

Go のスケジューラは、2 種類のキューを使います

<strong>ローカルキュー</strong>

各 P が持つキューで、新しく作られた goroutine はここに追加されます

ロックなしでアクセスできます

<strong>グローバルキュー</strong>

全 P で共有されるキューです

ローカルキューが溢れたり、ワークスティーリングで取得したりするときに使います

アクセスにはロックが必要です

### ワークスティーリングの詳細

P が暇になった（ローカルキューが空になった）とき、以下の順序で仕事を探します

1. ローカルキューを確認（空のはず）
2. グローバルキューを確認
3. ネットワークポーラーを確認（I/O 完了した goroutine）
4. 他の P からスティール

スティールするとき、他の P のキューの半分を奪います

これにより、負荷が均等に分散されます

---

## ブロッキング操作の扱い

### 問題: ブロッキング I/O

軽量スレッドで困るのは、ブロッキング I/O です

ブロッキング I/O を実行すると、OS スレッド全体がブロックされます

そのスレッド上の他の軽量スレッドも実行できなくなります

### 解決策 1: 非同期 I/O への変換

多くの軽量スレッド実装は、ブロッキング I/O を非同期 I/O に変換します

```
/*
 * 同期的に見える
 */
ユーザーコード: file.Read()

ランタイム内部:
1. 非同期 I/O を開始
2. 現在の goroutine を待機状態にする
3. 他の goroutine を実行
4. I/O 完了の通知を受け取る
5. goroutine を実行可能状態に戻す
```

Go では、<strong>netpoller</strong>という仕組みでこれを実現しています

Linux では `epoll`、macOS では `kqueue` を使用します

### 解決策 2: 専用スレッドでブロック

システムコールなど、どうしてもブロックが避けられない場合があります

Go では、そのような場合に M を増やして対処します

```
1. goroutine G1 がシステムコールを呼ぶ
2. P は G1 を手放し、新しい M を作成または再利用
3. 新しい M が P と結合し、他の goroutine を実行
4. G1 がシステムコールから戻る
5. G1 は空いている P を探すか、グローバルキューに入る
```

これを<strong>ハンドオフ</strong>と呼びます

---

## 各言語の軽量スレッド

### Go の goroutine

| 項目             | 詳細                               |
| ---------------- | ---------------------------------- |
| 初期スタック     | 数 KB（可変）                      |
| スケジューリング | プリエンプティブ                   |
| 並列実行         | 可能（複数の OS スレッド）         |
| 特徴             | シンプルな構文、チャネルによる通信 |

```go
go func() {
    /*
     * 並行実行される
     */
}()
```

### Erlang/Elixir のプロセス

Erlang の「プロセス」は、OS のプロセスとは異なり、軽量スレッドです

| 項目             | 詳細                                   |
| ---------------- | -------------------------------------- |
| 初期メモリ       | 数百バイト                             |
| スケジューリング | プリエンプティブ（リダクションベース） |
| 並列実行         | 可能                                   |
| 特徴             | 完全な分離、メッセージパッシング       |

Erlang プロセスは、メモリを共有しません

プロセス間の通信は、すべてメッセージのコピーで行われます

これにより、1 つのプロセスがクラッシュしても他に影響しません

### Java の Virtual Threads

Java 21 で導入された<strong>Virtual Threads</strong>は、Java の軽量スレッドです

| 項目             | 詳細                               |
| ---------------- | ---------------------------------- |
| スケジューリング | 非協調的（I/O で自動マウント解除） |
| 並列実行         | 可能                               |
| 特徴             | 既存の Thread API と互換性あり     |

```java
Thread.startVirtualThread(() -> {
    /*
     * 仮想スレッドで実行
     */
});
```

既存の `synchronized` や `Thread.sleep` もそのまま使えます

### 比較表

| 言語   | 軽量スレッド   | 並列 | スケジューリング | 特徴                   |
| ------ | -------------- | ---- | ---------------- | ---------------------- |
| Go     | goroutine      | 可能 | プリエンプティブ | チャネル               |
| Erlang | process        | 可能 | プリエンプティブ | 完全分離               |
| Java   | Virtual Thread | 可能 | 非協調的         | 既存 API 互換          |
| Kotlin | Coroutine      | 可能 | 協調的           | Structured Concurrency |

---

## 用語集

| 用語                 | 英語               | 説明                                   |
| -------------------- | ------------------ | -------------------------------------- |
| 軽量スレッド         | Lightweight Thread | ランタイムが管理するスレッド           |
| グリーンスレッド     | Green Thread       | 軽量スレッドの別名                     |
| C10K 問題            | C10K Problem       | 1 万同時接続の処理課題                 |
| スタックコピー       | Stack Copying      | スタックを新しい領域にコピーして拡張   |
| セグメント化スタック | Segmented Stack    | スタックを分割して管理する方式         |
| ホットスプリット     | Hot Split          | スタック境界の頻繁な跨ぎによる性能低下 |
| ローカルキュー       | Local Queue        | 各 P が持つ実行可能 goroutine のキュー |
| グローバルキュー     | Global Queue       | 全 P で共有するキュー                  |
| ワークスティーリング | Work Stealing      | 暇な P が他から仕事を奪う方式          |
| netpoller            | netpoller          | Go のネットワーク I/O 多重化機構       |
| ハンドオフ           | Handoff            | ブロック時に P を別の M に渡すこと     |
| Virtual Threads      | Virtual Threads    | Java 21 の軽量スレッド                 |
| リダクション         | Reduction          | Erlang のスケジューリング単位          |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>Go</strong>

- [The Go scheduler](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)
  - Go スケジューラの詳細解説
- [Go Runtime](https://pkg.go.dev/runtime)
  - Go ランタイムのドキュメント

<strong>Erlang</strong>

- [The BEAM Book](https://blog.stenmans.org/theBeamBook/)
  - Erlang VM の内部構造

<strong>Java</strong>

- [JEP 444: Virtual Threads](https://openjdk.org/jeps/444)
  - Java Virtual Threads の仕様

<strong>一般</strong>

- [C10K Problem](http://www.kegel.com/c10k.html)
  - C10K 問題の原典

<strong>本編との関連</strong>

- [06-concurrency](../06-concurrency.md)
  - 並行処理の基本
