<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 02-compilation：プログラムが実行可能になるまで

## はじめに

[01-runtime](./01-runtime.md) で、ランタイムが「プログラムを実行するためのソフトウェア環境」であることを学びました

ランタイムは、メモリ管理や OS との橋渡しなど、さまざまな責務を担っています

しかし、一つ疑問が残ります

「ソースコードは、<strong>どうやって実行可能な形になる</strong>のでしょうか？」

C 言語は「コンパイル」が必要ですが、Python は `.py` ファイルをそのまま実行できます

Java は `.java` から `.class` になりますが、これは何をしているのでしょうか？

このページでは、プログラムが「実行可能な形」になるまでの過程を学びます

### 日常の例え

料理を作ることを想像してください

<strong>ソースコード</strong>は、手書きのレシピです

人間が読める形で書かれています

しかし、調理器具（CPU）は手書きのレシピをそのまま理解できません

調理器具が理解できる形式に変換する必要があります

この「変換」の方法が、言語によって異なるのです

| 変換方式       | 料理の例え                                                                   |
| -------------- | ---------------------------------------------------------------------------- |
| AOT コンパイル | すべての料理を事前に完成させておき、注文が来たらすぐに提供する               |
| JIT コンパイル | 最初はレシピを見ながら作り、何度も注文されるメニューは手順を覚えて素早く作る |
| インタプリタ   | レシピを見ながら、その場で一品ずつ作る                                       |

それぞれの方式には、メリットとデメリットがあります

このページで、その違いを理解しましょう

### このページで学ぶこと

このページでは、以下の概念を学びます

- <strong>コンパイルとは何か</strong>
  - ソースコードを実行可能な形に変換する
- <strong>コンパイルのフェーズ</strong>
  - 字句解析から機械語生成まで
- <strong>3 つの実行モデル</strong>
  - AOT、JIT、インタプリタの違い
- <strong>言語ごとの比較</strong>
  - C、Go、Python、Java の実行方式
- <strong>実行ファイルとは何か</strong>
  - ELF 形式の概要

---

## 目次

1. [コンパイルとは何か](#コンパイルとは何か)
2. [コンパイルのフェーズ](#コンパイルのフェーズ)
3. [3 つの実行モデル](#3-つの実行モデル)
4. [言語ごとの比較](#言語ごとの比較)
5. [実行ファイルとは何か](#実行ファイルとは何か)
6. [リンクとライブラリ](#リンクとライブラリ)
7. [用語集](#用語集)
8. [参考資料](#参考資料)
9. [次のステップ](#次のステップ)

---

## コンパイルとは何か

### なぜ変換が必要なのか

CPU は<strong>機械語</strong>しか理解できません

機械語とは、0 と 1 の羅列です

人間が読み書きするには不便すぎます

そこで、人間が読みやすい<strong>ソースコード</strong>を書き、それを機械語に変換するのです

この変換を行うプログラムが<strong>コンパイラ</strong>です

### コンパイラの役割

コンパイラは、ソースコードを入力として受け取り、機械語（または中間形式）を出力します

```
ソースコード → [コンパイラ] → 機械語（実行ファイル）
```

コンパイラが行う変換は、単なる「翻訳」ではありません

- 文法エラーを検出する
- 効率の良いコードに最適化する
- ターゲット環境に合わせた機械語を生成する

これらの処理を経て、実行可能なファイルが生成されます

---

## コンパイルのフェーズ

コンパイラは、内部で複数のフェーズに分かれた処理を行います

ここでは概要だけを紹介します

### フロントエンド

<strong>フロントエンド</strong>は、ソースコードを解析する部分です（Web 開発の「フロントエンド」とは異なる、コンパイラ用語です）

| フェーズ | 役割                          |
| -------- | ----------------------------- |
| 字句解析 | ソースコードをトークンに分割  |
| 構文解析 | トークンを構文木（AST）に変換 |
| 意味解析 | 型チェックや変数の解決        |

例えば、`int x = 1 + 2;` というコードは、まず `int`、`x`、`=`、`1`、`+`、`2`、`;` というトークンに分割されます

次に、これらのトークンが正しい文法に従っているかチェックされます

### 中間表現

<strong>中間表現（IR）</strong>は、フロントエンドとバックエンドをつなぐ「共通言語」です

LLVM（多くの言語で使われるコンパイラ基盤）では「LLVM IR」という中間表現が使われています

中間表現を使うことで、フロントエンド（言語ごと）とバックエンド（CPU ごと）を分離できます

#### 歴史的背景

従来のコンパイラは、フロントエンド（構文解析）とバックエンド（コード生成）が密結合していました

LLVM プロジェクトが始まった頃、「中間表現を標準化すれば、フロントエンドとバックエンドを分離できる」というアイデアが提唱されました

これにより、新しい言語を作る人は LLVM IR を出力すれば、既存の最適化とコード生成を再利用できるようになりました

### バックエンド

<strong>バックエンド</strong>は、中間表現から機械語を生成する部分です

| フェーズ   | 役割                              |
| ---------- | --------------------------------- |
| 最適化     | コードを効率的に変換              |
| コード生成 | ターゲット CPU 向けの機械語を出力 |

最適化では、不要な計算の削除、ループの効率化などが行われます

### 全体の流れ

```
ソースコード
    ↓
[字句解析] → トークン列
    ↓
[構文解析] → 構文木（AST）
    ↓
[意味解析] → 型情報付き AST
    ↓
[中間表現生成] → IR
    ↓
[最適化] → 最適化された IR
    ↓
[コード生成] → 機械語
```

この流れを理解しておくと、コンパイラエラーの意味が分かりやすくなります

「構文エラー」は構文解析フェーズで、「型エラー」は意味解析フェーズで発生します

---

## 3 つの実行モデル

プログラムを実行する方法は、大きく 3 つに分類できます

### AOT（Ahead-of-Time）コンパイル

<strong>AOT コンパイル</strong>は、実行前にすべてのコードを機械語に変換する方式です

| 特徴           | 説明                     |
| -------------- | ------------------------ |
| 変換タイミング | 実行前（ビルド時）       |
| 実行速度       | 高速（事前に最適化済み） |
| 起動時間       | 高速（変換作業が不要）   |
| 代表的な言語   | C、C++、Go、Rust         |

C 言語でプログラムを書くと、`gcc` でコンパイルして実行ファイルを作成します

この実行ファイルには、すでに機械語が含まれています

### インタプリタ

<strong>インタプリタ</strong>は、ソースコードを一行ずつ解釈しながら実行する方式です

| 特徴           | 説明                                    |
| -------------- | --------------------------------------- |
| 変換タイミング | 実行中（逐次）                          |
| 実行速度       | 比較的遅い（逐次解釈のオーバーヘッド）  |
| 起動時間       | 高速（コンパイル不要）                  |
| 代表的な言語   | Python、Ruby、JavaScript（V8 登場以前） |

Python の場合、`python script.py` と実行すると、インタプリタがソースコードを読み取りながら実行します

実際には、CPython はソースコードをバイトコードに変換してから実行しますが、これも「インタプリタ」に分類されます

### JIT（Just-in-Time）コンパイル

<strong>JIT コンパイル</strong>は、実行時に必要な部分だけを機械語に変換する方式です

| 特徴           | 説明                             |
| -------------- | -------------------------------- |
| 変換タイミング | 実行中（必要に応じて）           |
| 実行速度       | 高速（ホットスポットを最適化）   |
| 起動時間       | やや遅い（初期コンパイルが必要） |
| 代表的な言語   | Java、JavaScript（V8）、C#       |

JIT コンパイラは、頻繁に実行されるコード（<strong>ホットスポット</strong>）を見つけ、それを積極的に最適化します

実行しながら「どのコードがよく使われるか」を観察できるため、AOT よりも効果的な最適化ができる場合があります

#### 歴史的背景

Self 言語が登場した頃、「実行時に機械語を生成すれば、静的コンパイルでは得られない最適化ができる」という発見がありました

これが JIT コンパイルの始まりです

Self 言語の研究者たちは後に Java の HotSpot JVM の開発にも携わりました

### 比較表

| 項目           | AOT    | インタプリタ | JIT      |
| -------------- | ------ | ------------ | -------- |
| 変換タイミング | 実行前 | 実行中       | 実行中   |
| 実行速度       | 高速   | 遅い         | 高速     |
| 起動時間       | 高速   | 高速         | やや遅い |
| メモリ使用     | 少ない | 中程度       | 多い     |
| デバッグ       | やや難 | 容易         | 中程度   |

JIT がメモリを多く使うのは、コンパイル結果のキャッシュやプロファイル情報（どのコードが頻繁に実行されるか）を保持するためです

インタプリタはソースコードをそのまま実行するため、デバッグ時に元のコードとの対応が取りやすくなります

どの方式が「最良」というわけではありません

用途に応じて、適切な方式を選択することが重要です

---

## 言語ごとの比較

実際の言語が、どのような実行モデルを採用しているかを見てみましょう

### C 言語：AOT の代表

C 言語は、AOT コンパイルの代表的な言語です

```
hello.c → [gcc] → hello（実行ファイル）
```

コンパイルすると、機械語を含む実行ファイルが生成されます

この実行ファイルは、C 言語のランタイムである libc（標準ライブラリ）に依存しますが、コンパイラ自体は必要ありません

### Go：シングルバイナリ

Go も AOT コンパイル言語ですが、特徴的なのは<strong>シングルバイナリ</strong>を生成することです

```
hello.go → [go build] → hello（単一の実行ファイル）
```

Go の実行ファイルには、ランタイム（GC、スケジューラなど）も含まれています

そのため、実行ファイルのサイズは大きくなりますが、他の環境に依存せずに実行できます

### Python：インタプリタ + バイトコード

Python は、ソースコードをバイトコードに変換してからインタプリタで実行します

```
hello.py → [CPython] → バイトコード（.pyc） → [CPython VM] → 実行
```

バイトコードは `__pycache__` ディレクトリにキャッシュされます

しかし、バイトコードの実行自体はインタプリタが行うため、実行速度は AOT に劣ります

### Java：バイトコード + JIT

Java は、ソースコードをバイトコードにコンパイルし、JVM が JIT コンパイルしながら実行します

```
Hello.java → [javac] → Hello.class（バイトコード） → [JVM + JIT] → 実行
```

JVM は起動時にバイトコードをインタプリタで実行しますが、頻繁に実行されるメソッドは JIT コンパイルで機械語に変換されます

これにより、長時間動作するアプリケーションでは高い性能を発揮します

### 比較表

| 言語   | 実行モデル         | コンパイル結果      | 実行に必要なもの |
| ------ | ------------------ | ------------------- | ---------------- |
| C      | AOT                | 機械語              | libc             |
| Go     | AOT                | 機械語 + ランタイム | なし             |
| Python | インタプリタ       | バイトコード        | CPython          |
| Java   | バイトコード + JIT | バイトコード        | JVM              |

---

## 実行ファイルとは何か

AOT コンパイルで生成される「実行ファイル」とは、具体的に何でしょうか？

### ELF 形式

Linux では、実行ファイルは<strong>ELF（Executable and Linkable Format）</strong>という形式で保存されます

ELF ファイルは、単なる機械語の羅列ではありません

以下のような構造を持っています

| セクション       | 内容                             |
| ---------------- | -------------------------------- |
| ELF ヘッダ       | ファイル形式やアーキテクチャ情報 |
| プログラムヘッダ | メモリへの配置方法               |
| .text            | 実行可能な機械語                 |
| .data            | 初期化済みグローバル変数         |
| .bss             | 未初期化グローバル変数           |
| .rodata          | 読み取り専用データ（文字列など） |

.bss は「Block Started by Symbol」の略で、歴史的な名前です

.rodata は「read-only data」の略です

### file コマンドで確認

`file` コマンドで、実行ファイルの形式を確認できます

```bash
$ file /bin/ls
/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, ...
```

この出力から、以下のことが分かります

- ELF 形式である
- 64 ビットである
- x86-64 アーキテクチャ向けである
- 動的リンクされている（次のセクションで詳しく説明します）

### 実行ファイルの起動

実行ファイルが起動されると、前のシリーズで学んだ `execve()` システムコールが呼ばれます

カーネルは ELF ファイルを読み取り、メモリに配置し、エントリーポイントから実行を開始します

---

## リンクとライブラリ

コンパイルだけでは、実行ファイルは完成しません

<strong>リンク</strong>という工程が必要です

### リンクとは

複数のオブジェクトファイル（`.o`）を結合し、一つの実行ファイルを作成する工程です

```
main.o + utils.o + libc → [リンカ] → 実行ファイル
```

リンカは、各オブジェクトファイル内の関数呼び出しを解決し、正しいアドレスを設定します

### 静的リンクと動的リンク

リンクには 2 つの方式があります

| 方式       | 説明                                       |
| ---------- | ------------------------------------------ |
| 静的リンク | ライブラリのコードを実行ファイルに埋め込む |
| 動的リンク | 実行時にライブラリを読み込む               |

動的リンクでは、`libc.so` などの共有ライブラリを実行時に読み込みます

これにより、実行ファイルのサイズを小さくできますが、実行環境にライブラリが必要になります

### ldd コマンド

`ldd` コマンドで、動的リンクされているライブラリを確認できます

```bash
$ ldd /bin/ls
    linux-vdso.so.1 (0x00007ffd...)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f...)
    /lib64/ld-linux-x86-64.so.2 (0x00007f...)
```

`linux-vdso.so.1` はカーネルが提供する仮想的なライブラリで、高速なシステムコールを可能にします（詳細は省略します）

`libc.so.6` が C 標準ライブラリです

`ld-linux-x86-64.so.2` は動的リンカで、実行時にライブラリを読み込む役割を担います

---

## 用語集

| 用語                 | 英語                             | 説明                                                             |
| -------------------- | -------------------------------- | ---------------------------------------------------------------- |
| コンパイル           | Compile                          | ソースコードを機械語に変換すること                               |
| コンパイラ           | Compiler                         | コンパイルを行うプログラム                                       |
| インタプリタ         | Interpreter                      | ソースコードを逐次解釈して実行するプログラム                     |
| 機械語               | Machine Code                     | CPU が直接実行できる命令                                         |
| バイトコード         | Bytecode                         | 仮想マシン向けの中間コード                                       |
| AOT                  | Ahead-of-Time                    | 実行前に機械語に変換する方式                                     |
| JIT                  | Just-in-Time                     | 実行中に機械語に変換する方式                                     |
| 中間表現             | Intermediate Representation / IR | フロントエンドとバックエンドをつなぐコード形式                   |
| 字句解析             | Lexical Analysis                 | ソースコードをトークンに分割する処理                             |
| 構文解析             | Syntax Analysis / Parsing        | トークン列を構文木に変換する処理                                 |
| 意味解析             | Semantic Analysis                | 型チェックや変数の解決を行う処理                                 |
| トークン             | Token                            | ソースコードを構成する最小単位（キーワード、識別子、演算子など） |
| 構文木               | Abstract Syntax Tree / AST       | ソースコードの構造を木構造で表現したもの                         |
| フロントエンド       | Frontend（Compiler）             | コンパイラの前半部分（字句・構文・意味解析を担当）               |
| バックエンド         | Backend（Compiler）              | コンパイラの後半部分（最適化・コード生成を担当）                 |
| リンク               | Link                             | オブジェクトファイルを結合して実行ファイルを作る                 |
| オブジェクトファイル | Object File                      | コンパイル後、リンク前の中間ファイル（.o）                       |
| 静的リンク           | Static Linking                   | ライブラリを実行ファイルに埋め込む                               |
| 動的リンク           | Dynamic Linking                  | 実行時にライブラリを読み込む                                     |
| 共有ライブラリ       | Shared Library                   | 実行時に読み込まれるライブラリ（.so）                            |
| ELF                  | Executable and Linkable Format   | Linux の実行ファイル形式                                         |
| ホットスポット       | Hotspot                          | 頻繁に実行されるコード部分                                       |
| 最適化               | Optimization                     | コードの効率を向上させる変換                                     |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>コンパイラ</strong>

- [GCC Online Documentation](https://gcc.gnu.org/onlinedocs/)
  - GCC の公式ドキュメント
- [The LLVM Compiler Infrastructure](https://llvm.org/)
  - LLVM プロジェクトの公式サイト

<strong>言語ランタイム</strong>

- [Go Build](https://pkg.go.dev/cmd/go#hdr-Compile_packages_and_dependencies)
  - Go のビルドプロセス
- [CPython Internals](https://devguide.python.org/internals/)
  - CPython のバイトコード実行
- [The Java Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se21/html/index.html)
  - JVM の公式仕様

<strong>実行ファイル形式</strong>

- [Executable and Linkable Format - Wikipedia](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)
  - ELF 形式の概要
- [ld.so(8) - Linux manual page](https://man7.org/linux/man-pages/man8/ld.so.8.html)
  - 動的リンカ

---

## 次のステップ

このトピックでは、プログラムが「実行可能な形」になるまでの過程を学びました

JIT コンパイルやインタプリタが「バイトコード」を実行すると説明しました

次の [03-vm](./03-vm.md) では、このバイトコードを実行する<strong>「仮想マシン」</strong>について学びます

- 仮想マシンとは何か
- なぜ仮想マシンが必要なのか
- JVM、CPython VM、V8 の違い

これらの疑問に答えていきます
