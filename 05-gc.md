<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 05-gc：ガベージコレクション

## はじめに

[04-stack-heap](./04-stack-heap.md) で、ヒープメモリは「手動または GC で解放する」と学びました

C 言語では `free()` で手動解放しますが、Java や Go では自動的に解放されます

この「自動解放」の仕組みが<strong>ガベージコレクション（GC）</strong>です

しかし、GC は「魔法」ではありません

どのメモリが「不要」かを判断し、適切なタイミングで回収する必要があります

このページでは、GC の仕組みと基本的なアルゴリズムを学びます

### 日常の例え

街のゴミ収集を想像してください

<strong>ヒープ</strong>は街全体です

<strong>オブジェクト</strong>は街にある家です

<strong>参照</strong>は家から家への一方通行の道路です

<strong>ルート</strong>は市役所です

市役所から道路をたどって行ける家は、必要な家です

どの道路からもたどり着けない家は、誰にも利用されていない空き家です

<strong>GC</strong> はゴミ収集員です

ゴミ収集員は、市役所から道路をたどり、到達できない家を「ゴミ」と判断して回収します

| 概念         | 日常の例え                             |
| ------------ | -------------------------------------- |
| ヒープ       | 街全体                                 |
| オブジェクト | 家                                     |
| 参照         | 家から家への一方通行の道路             |
| ルート       | 市役所（起点）                         |
| GC           | ゴミ収集員                             |
| マーク       | 「この家は利用されている」と印を付ける |
| スイープ     | 印のない家を解体する                   |

### このページで学ぶこと

このページでは、以下の概念を学びます

- <strong>なぜ GC が必要か</strong>
  - 手動管理の問題点
- <strong>「ゴミ」の定義</strong>
  - 到達可能性（Reachability）
- <strong>基本的な GC アルゴリズム</strong>
  - 参照カウント、マーク&スイープ、世代別 GC
- <strong>GC のトレードオフ</strong>
  - スループット vs レイテンシ

---

## 目次

1. [なぜ GC が必要か](#なぜ-gc-が必要か)
2. [「ゴミ」の定義](#ゴミの定義)
3. [基本的な GC アルゴリズム](#基本的な-gc-アルゴリズム)
4. [GC とアプリケーションの関係](#gc-とアプリケーションの関係)
5. [言語ごとの GC](#言語ごとの-gc)
6. [GC のトレードオフ](#gc-のトレードオフ)
7. [用語集](#用語集)
8. [参考資料](#参考資料)
9. [次のステップ](#次のステップ)

---

## なぜ GC が必要か

### 手動管理の問題点

C 言語では、プログラマが `malloc()` と `free()` でメモリを管理します

しかし、手動管理には問題があります

<strong>メモリリーク</strong>

`free()` を呼び忘れると、メモリが解放されません

```c
void leak() {
    int *p = malloc(1000);
    /* free(p) を忘れた */
}  /* メモリは確保されたまま */
```

<strong>二重解放</strong>

同じメモリを 2 回 `free()` すると、クラッシュやセキュリティ問題が発生します

```c
int *p = malloc(1000);
free(p);
free(p);  /* 二重解放：未定義動作 */
```

<strong>解放後アクセス（Use After Free）</strong>

解放したメモリにアクセスすると、未定義動作になります

```c
int *p = malloc(sizeof(int));
*p = 42;
free(p);
printf("%d\n", *p);  /* 解放後アクセス：未定義動作 */
```

### GC のメリット

GC があれば、これらの問題を避けられます

| 問題           | GC の対策                    |
| -------------- | ---------------------------- |
| メモリリーク   | 不要なメモリを自動で回収     |
| 二重解放       | プログラマは解放を意識しない |
| 解放後アクセス | 参照がある間は解放されない   |

GC により、プログラマはメモリ管理から解放され、ビジネスロジックに集中できます

### GC の誕生

GC は Lisp 誕生の頃、John McCarthy によって発明されました

Lisp はリスト処理言語で、プログラム実行中に大量のリストが作られては捨てられます

手動管理では追いつかないため、「使われなくなったメモリを自動で回収する」仕組みが必要でした

これが GC の始まりです

---

## 「ゴミ」の定義

GC は、どのメモリが「不要」かを判断する必要があります

### 到達可能性

GC における「ゴミ」の定義は<strong>到達可能性（Reachability）</strong>に基づきます

<strong>ルート</strong>から<strong>参照</strong>をたどって到達できるオブジェクトは、生きています

到達できないオブジェクトは、ゴミです

### ルートとは

<strong>ルート</strong>は、GC の起点となる参照です

| ルートの種類     | 説明                             |
| ---------------- | -------------------------------- |
| グローバル変数   | プログラム全体からアクセス可能   |
| スタック上の変数 | 現在実行中の関数のローカル変数   |
| レジスタ         | CPU レジスタに保持されている参照 |

### 到達可能性の例

```java
Object a = new Object();  /* a はルートから到達可能 */
Object b = new Object();  /* b もルートから到達可能 */
a = null;                 /* a が指していたオブジェクトは到達不能 → ゴミ */
```

最初は `a` と `b` の両方が生きています

`a = null;` により、`a` が指していたオブジェクトへの参照がなくなります

このオブジェクトはルートから到達できなくなり、ゴミとなります

### 循環参照

2 つのオブジェクトが互いを参照している場合を考えます

```java
class Node {
    Node next;
}

Node x = new Node();
Node y = new Node();
x.next = y;
y.next = x;  /* 循環参照 */
x = null;
y = null;    /* ルートからは到達不能だが、互いに参照し合っている */
```

ルートから到達できなくなれば、循環参照していてもゴミです

参照カウント方式では循環参照を検出できませんが、マーク&スイープ方式では検出できます

---

## 基本的な GC アルゴリズム

GC には、いくつかの基本的なアルゴリズムがあります

### 参照カウント

<strong>参照カウント</strong>は、各オブジェクトへの参照数を数える方式です

参照数が 0 になったら、そのオブジェクトを解放します

| 操作         | カウントの変化     |
| ------------ | ------------------ |
| 参照を作成   | カウント +1        |
| 参照を削除   | カウント -1        |
| カウント = 0 | オブジェクトを解放 |

<strong>メリット</strong>

- 不要になったらすぐに解放される
- 実装が比較的シンプル

<strong>デメリット</strong>

- 循環参照を検出できない
- 参照操作のたびにカウント更新が必要

Python（CPython）は参照カウントを使用しています

循環参照は別の仕組み（循環参照検出器）で対処しています

### マーク&スイープ

<strong>マーク&スイープ</strong>は、最も基本的な GC アルゴリズムです

2 つのフェーズで構成されます

<strong>マークフェーズ</strong>

ルートからたどれるすべてのオブジェクトに印を付けます

<strong>スイープフェーズ</strong>

印のないオブジェクトを解放します

```
1. すべてのオブジェクトの印を消す
2. ルートから参照をたどる
3. たどり着いたオブジェクトに印を付ける
4. 印のないオブジェクトを解放する
```

<strong>メリット</strong>

- 循環参照も正しく回収できる

<strong>デメリット</strong>

- GC 中はアプリケーションが停止する（Stop-the-World）
- 全オブジェクトを走査する必要がある

### 世代別 GC

<strong>世代別 GC</strong>は、オブジェクトを「世代」で分類する方式です

David Ungar は「ほとんどのオブジェクトは若くして死ぬ」という観察から、世代別 GC を提唱しました

この観察は<strong>弱い世代仮説</strong>（Weak Generational Hypothesis）と呼ばれ、多くのプログラムで確認されている傾向です

世代別 GC の設計根拠となっています

| 世代       | 説明                               |
| ---------- | ---------------------------------- |
| Young 世代 | 新しく作られたオブジェクト         |
| Old 世代   | 何度も GC を生き延びたオブジェクト |

<strong>動作</strong>

1. 新しいオブジェクトは Young 世代に配置
2. Young 世代の GC を頻繁に実行（マイナー GC）
3. 生き残ったオブジェクトを Old 世代に昇格
4. Old 世代の GC はたまに実行（メジャー GC）

<strong>メリット</strong>

- 毎回全オブジェクトを走査しなくて済む
- 多くのオブジェクトを効率的に回収

<strong>デメリット</strong>

- 実装が複雑
- 世代間の参照を管理する必要がある

JVM や V8 は世代別 GC を採用しています

### アルゴリズムの比較

| アルゴリズム    | 循環参照 | 一時停止   | 実装複雑度 |
| --------------- | -------- | ---------- | ---------- |
| 参照カウント    | 不可     | なし       | 低         |
| マーク&スイープ | 可能     | あり       | 中         |
| 世代別          | 可能     | 最小化可能 | 高         |

---

## GC とアプリケーションの関係

GC はメモリを自動管理しますが、アプリケーションに影響を与えることもあります

### Stop-the-World

多くの GC は、実行中にアプリケーションを一時停止させます

これを<strong>Stop-the-World（STW）</strong>と呼びます

```
アプリケーション: ----実行----[停止]----実行----
GC:                           [GC実行]
```

STW 中は、アプリケーションの処理が完全に止まります

レスポンスタイムが重要なアプリケーションでは、STW の長さが問題になります

### 並行 GC

<strong>並行 GC</strong>は、アプリケーションと並行して GC を実行します

```
アプリケーション: ----実行--------実行--------実行----
GC:                   [--並行GC実行--]
```

完全に STW をなくすことは難しいですが、停止時間を大幅に短縮できます

Go の GC は並行 GC を採用しており、STW は非常に短くなっています

### GC の頻度とメモリ使用量

GC には、メモリ使用量と GC 頻度のトレードオフがあります

| 設定         | GC 頻度 | メモリ使用量 |
| ------------ | ------- | ------------ |
| ヒープ小さい | 高い    | 少ない       |
| ヒープ大きい | 低い    | 多い         |

ヒープを大きくすると、GC の頻度は下がりますが、1 回の GC に時間がかかります

---

## 言語ごとの GC

主要な言語が採用している GC を見てみましょう

### Java

Java の JVM は、複数の GC 実装を提供しています

| GC 名       | 特徴                         |
| ----------- | ---------------------------- |
| G1GC        | デフォルト（バランス型）     |
| ZGC         | 超低レイテンシ（ミリ秒単位） |
| Parallel GC | スループット重視             |

Java では、用途に応じて GC を選択できます

### Go

Go は<strong>並行マーク&スイープ GC</strong>を採用しています

| 特徴     | 説明                           |
| -------- | ------------------------------ |
| 方式     | 並行マーク&スイープ            |
| 世代     | 世代別ではない                 |
| 停止時間 | 非常に短い（ミリ秒以下が目標） |

Go の GC は、低レイテンシを最優先に設計されています

### Python（CPython）

CPython は<strong>参照カウント + 循環参照検出器</strong>を使用しています

| 特徴   | 説明           |
| ------ | -------------- |
| 主方式 | 参照カウント   |
| 補助   | 循環参照検出器 |
| 世代   | 世代別         |

参照カウントにより、不要になったオブジェクトはすぐに解放されます

循環参照だけが、循環参照検出器で回収されます

### 比較表

| 言語   | 主な方式            | 世代別 | 並行 GC |
| ------ | ------------------- | ------ | ------- |
| Java   | マーク&スイープ系   | あり   | あり    |
| Go     | 並行マーク&スイープ | なし   | あり    |
| Python | 参照カウント        | あり   | なし    |

---

## GC のトレードオフ

GC には、いくつかのトレードオフがあります

### スループット vs レイテンシ

| 指標         | 説明                       |
| ------------ | -------------------------- |
| スループット | 単位時間あたりの処理量     |
| レイテンシ   | 1 回のリクエストの応答時間 |

スループットを重視すると、GC を「まとめて」実行する方が効率的です

しかし、まとめて実行すると STW が長くなり、レイテンシが悪化します

レイテンシを重視すると、GC を「こまめに」実行する方が良いです

しかし、こまめに実行すると GC のオーバーヘッドが増え、スループットが下がります

### メモリ使用量 vs GC 頻度

ヒープを大きくすると GC 頻度は下がりますが、メモリ使用量は増えます

### 用途に応じた選択

| 用途       | 優先すべき指標 | 適した GC    |
| ---------- | -------------- | ------------ |
| バッチ処理 | スループット   | Parallel GC  |
| Web サーバ | レイテンシ     | ZGC、Go GC   |
| 組み込み   | メモリ使用量   | 小さいヒープ |

---

## 用語集

| 用語                 | 英語                    | 説明                                           |
| -------------------- | ----------------------- | ---------------------------------------------- |
| ガベージコレクション | Garbage Collection / GC | 不要なメモリを自動で回収する仕組み             |
| 到達可能性           | Reachability            | ルートから参照をたどって到達できるかどうか     |
| ルート               | Root                    | GC の起点となる参照                            |
| 参照カウント         | Reference Counting      | 参照数を数えて管理する方式                     |
| マーク&スイープ      | Mark and Sweep          | 到達可能なオブジェクトに印を付けて回収する方式 |
| 世代別 GC            | Generational GC         | オブジェクトを世代で分類して管理する方式       |
| Stop-the-World       | Stop-the-World / STW    | GC 中にアプリケーションを停止すること          |
| 並行 GC              | Concurrent GC           | アプリケーションと並行して GC を実行           |
| マイナー GC          | Minor GC                | Young 世代のみの GC                            |
| メジャー GC          | Major GC                | Old 世代を含む全体の GC                        |
| 循環参照             | Circular Reference      | 複数のオブジェクトが互いを参照し合う状態       |
| スループット         | Throughput              | 単位時間あたりの処理量                         |
| レイテンシ           | Latency                 | 応答時間                                       |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>理論</strong>

- [The Garbage Collection Handbook](https://gchandbook.org/)
  - GC の包括的な解説書

<strong>Java</strong>

- [JVM Garbage Collectors](https://docs.oracle.com/en/java/javase/21/gctuning/)
  - JVM の GC チューニングガイド

<strong>Go</strong>

- [Go GC Guide](https://tip.golang.org/doc/gc-guide)
  - Go の GC 解説

<strong>Python</strong>

- [gc - Garbage Collector interface](https://docs.python.org/3/library/gc.html)
  - Python の GC モジュール

---

## 次のステップ

このトピックでは、ガベージコレクションの仕組みを学びました

GC は、ランタイムがメモリを管理する重要な仕組みです

次の [06-concurrency](./06-concurrency.md) では、ランタイムのもう一つの重要な責務である<strong>「並行処理」</strong>について学びます

- OS スレッドと軽量スレッドの違い
- goroutine や async/await の仕組み
- ランタイムスケジューラの役割

これらの疑問に答えていきます
