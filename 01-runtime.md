<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 01-runtime：ランタイムとは何か

## はじめに

前のシリーズで、「プロセスとは実行中のプログラム」であることを学びました

プロセスは、メモリ空間、ファイルディスクリプタ、環境変数などを持っています

しかし、一つ疑問が残ります

「プロセスの中で、プログラムのコードは<strong>誰がどうやって実行している</strong>のでしょうか？」

C 言語で書いたプログラムは、コンパイルすると機械語になり、CPU が直接命令を実行します

では、Python や Java はどうでしょうか？

Python のソースコードを CPU が直接実行することはできません

CPU が理解できるのは機械語（0 と 1 の命令列）だけだからです

Java の `.class` ファイルも、CPU が直接理解できる形式ではありません

実は、Python や Java には<strong>「ランタイム」</strong>と呼ばれるものが間に入っています

このページでは、その「ランタイム」について学びます

### 日常の例え

劇場での演劇を想像してください

<strong>台本</strong>（脚本）があります

これがプログラム（ソースコード）に相当します

しかし、台本があるだけでは演劇は始まりません

<strong>劇場</strong>という「場」が必要です

これがプロセスに相当します

さて、劇場があっても、台本を役者にそのまま渡すだけでは演劇はうまくいきません

台本を解釈し、役者に指示を出し、照明や音響を調整し、舞台転換を行う

そういった<strong>「舞台監督と裏方スタッフ」</strong>が必要です

ランタイムは、この<strong>「舞台監督と裏方スタッフ」</strong>に相当します

| 概念                       | 日常の例え             |
| -------------------------- | ---------------------- |
| プログラム（ソースコード） | 台本（脚本）           |
| プロセス                   | 劇場（上演中の状態）   |
| ランタイム                 | 舞台監督と裏方スタッフ |
| CPU                        | 役者                   |
| OS                         | 劇場の建物と設備       |

言語によって、この「裏方」の役割は大きく異なります

| 言語タイプ                 | 例え                                                                 |
| -------------------------- | -------------------------------------------------------------------- |
| C 言語（ランタイム最小限） | 台本が「役者への直接指示」形式で書かれており、舞台監督はほぼ不要     |
| Python（インタプリタ型）   | 台本が「演出ノート」形式で、舞台監督が一行ずつ読んで役者に指示を出す |
| Java（VM 型）              | 台本が「共通フォーマット」で書かれており、どの劇場でも同じ演出が可能 |

### このページで学ぶこと

このページでは、以下の概念を学びます

- <strong>ランタイムとは何か</strong>
  - プログラムを実行するための「裏方」
- <strong>ランタイムの責務</strong>
  - メモリ管理、OS との橋渡し、言語機能の実現
- <strong>言語によるランタイムの違い</strong>
  - C、Python、Java、Go の違い
- <strong>ランタイムとプロセスの関係</strong>
  - ランタイムはプロセス内で動く
- <strong>ランタイムと OS の境界</strong>
  - どこまでがランタイムの仕事で、どこからが OS の仕事か

---

## 目次

1. [ランタイムとは何か](#ランタイムとは何か)
2. [ランタイムの責務](#ランタイムの責務)
3. [言語によるランタイムの違い](#言語によるランタイムの違い)
4. [ランタイムとプロセスの関係](#ランタイムとプロセスの関係)
5. [ランタイムと OS の境界](#ランタイムと-os-の境界)
6. [ランタイムを観察してみよう](#ランタイムを観察してみよう)
7. [用語集](#用語集)
8. [参考資料](#参考資料)
9. [次のステップ](#次のステップ)

---

## ランタイムとは何か

### 「ランタイム」という言葉の曖昧さ

「ランタイム」という言葉は、複数の意味で使われます

| 用語                | 意味                                       |
| ------------------- | ------------------------------------------ |
| runtime（形容詞的） | 実行時の（compile-time の対義語）          |
| runtime environment | 実行環境（JRE など）                       |
| runtime system      | 言語ランタイム（実行を支えるソフトウェア） |
| runtime library     | 実行時に使われるライブラリ                 |

例えば、「runtime error」と言えば「実行時エラー」のことです

これは「コンパイル時（compile-time）」の対義語として使われています

一方、「Java Runtime Environment（JRE）」と言えば、Java プログラムを実行するためのソフトウェア環境を指します

このドキュメントでは、<strong>「プログラムを実行するためのソフトウェア環境」</strong>という狭義の意味で「ランタイム」を使います

### ランタイムの定義

<strong>ランタイム</strong>とは、プログラムが実行されるときに必要となるソフトウェア環境のことです

具体的には、以下のような役割を担います

- プログラムの起動準備をする
- メモリを管理する
- OS との橋渡しをする
- 言語固有の機能を実現する
- プログラムの終了処理をする

言い換えると、<strong>「プログラマが書いたコード」と「OS やハードウェア」の間にいる仲介者</strong>です

---

## ランタイムの責務

ランタイムは、いったい何をしているのでしょうか？

### 1. プログラムの起動準備

プログラムが `main` 関数から始まると思っていませんか？

実は、`main` が呼ばれる前に、ランタイムがさまざまな準備をしています

- スタック領域の初期化
- ヒープ領域の準備
- コマンドライン引数の設定
- 環境変数の取得
- 標準入出力の準備

C 言語の場合、`crt0`（C Runtime Zero）や `crt1` と呼ばれるスタートアップコードがこの役割を担います

#### 歴史的背景

UNIX 初期、C 言語のプログラムは `main` 関数から始まるように設計されました

しかし `main` が呼ばれる前に、スタックの初期化やライブラリの準備が必要です

この準備を行うコードは<strong>スタートアップコード</strong>（crt0、crt1）と呼ばれ、UNIX とともに発展してきました

C 言語が国際標準化された頃、`main` 前後の動作も標準化され、現在の形になりました

### 2. メモリ管理

プログラムが `malloc()` でメモリを確保したり、`free()` で解放したりするとき、ランタイムが裏で管理しています

OS から大きなメモリブロックを借りてきて、それを細かく切り分けてプログラムに渡す

使い終わったメモリを回収して、再利用できるようにする

これがランタイムの重要な仕事です

一部の言語（Java、Go、Python など）では、<strong>ガベージコレクション（GC）</strong>という仕組みで、使い終わったメモリを自動的に解放します

これもランタイムの責務です

### 3. OS との橋渡し

ファイルを開く、ネットワーク通信する、新しいプロセスを作る

これらはすべて OS の機能を使う必要があります

ランタイムは、言語の API（例：Python の `open()`）を、OS のシステムコール（例：`open(2)`）に変換します

これにより、プログラマは OS の詳細を意識せずにプログラムを書くことができます

### 4. 言語固有機能の実現

言語によっては、OS が直接提供していない機能を持っています

- <strong>例外処理</strong>：try-catch のような仕組み
- <strong>軽量スレッド</strong>：Go の goroutine、Python の async/await
- <strong>リフレクション</strong>：実行時に型情報を取得する
- <strong>ガベージコレクション</strong>：自動メモリ管理

これらの機能は、ランタイムが実現しています

### 5. プログラムの終了処理

プログラムが終了するときも、ランタイムが後片付けをします

- 開いているファイルを閉じる
- 確保したメモリを解放する
- 終了コードを OS に返す

### 責務のまとめ

| 責務           | 説明                       | 例                         |
| -------------- | -------------------------- | -------------------------- |
| 起動準備       | main 関数の前の初期化      | スタック・ヒープの準備     |
| メモリ管理     | 動的メモリの管理           | malloc/free、GC            |
| OS との橋渡し  | システムコールの呼び出し   | ファイル操作、ネットワーク |
| 言語機能の実現 | 言語固有の機能             | 例外処理、goroutine        |
| 終了処理       | プログラム終了時の後片付け | リソース解放               |

---

## 言語によるランタイムの違い

言語によって、ランタイムの実装は大きく異なります

ここでは、4 つの言語を例に見ていきます

### C 言語：最小限のランタイム

C 言語は、<strong>ランタイムが最も小さい言語</strong>の一つです

C のランタイムは主に以下で構成されています

- <strong>libc</strong>（C 標準ライブラリ）
  - `printf()`、`malloc()`、`fopen()` などの関数を提供
- <strong>crt0 / crt1</strong>（C Runtime Startup）
  - `main` 関数の前後の処理を行う

C 言語のコードはコンパイルすると機械語になり、CPU が直接実行します

ランタイムは「お膳立て」と「後片付け」だけを担当し、実行中の介入は最小限です

#### なぜ libc は標準化されたか

UNIX 初期、C 言語は UNIX の実装言語として開発されました

当時は UNIX ごとに libc の実装が異なり、プログラムの移植が困難でした

そこで C 言語が国際標準化された際、標準ライブラリ（libc）の仕様も定められました

これにより、どの環境でも `printf()` や `malloc()` が同じように動くことが保証されるようになりました

### Python：インタプリタ型

Python には<strong>インタプリタ</strong>と呼ばれるランタイムがあります

最も広く使われている実装は<strong>CPython</strong>です

Python のランタイムは以下のことをします

- ソースコードをバイトコード（`.pyc`）に変換
- バイトコードを命令単位で解釈して実行
- ガベージコレクションでメモリを自動管理
- GIL（Global Interpreter Lock）という Python 固有の仕組みでマルチスレッド実行を制限（メモリ管理の安全性を保つため）

Python プログラムを実行すると、実際には `python` コマンド（インタプリタ）が動いています

そのインタプリタがソースコードを読み取り、実行しているのです

### Java：VM 型

Java には<strong>JVM（Java Virtual Machine）</strong>というランタイムがあります

Java のランタイムは以下のことをします

- バイトコード（`.class`）を実行
- JIT（Just-In-Time）コンパイラで機械語に変換
- ガベージコレクションでメモリを自動管理
- クラスのロードと検証

Java の「Write Once, Run Anywhere」は、JVM が間に入ることで実現しています

同じバイトコードを、Windows でも Linux でも macOS でも、それぞれの JVM が実行できるのです

### Go：組み込みランタイム型

Go には<strong>ランタイムがバイナリに埋め込まれる</strong>という特徴があります

Go のランタイムは以下のことをします

- goroutine のスケジューリング
- ガベージコレクション
- スタックの動的拡張

Go のプログラムをコンパイルすると、ランタイムも一緒にバイナリに含まれます

そのため、Go の「Hello World」でもバイナリサイズがやや大きくなります

しかし、実行時に別のランタイムをインストールする必要がないという利点があります

### 比較表

| 言語   | ランタイムの形態 | 主な責務                  | 実行ファイルの特徴 |
| ------ | ---------------- | ------------------------- | ------------------ |
| C      | 最小限（libc）   | 起動/終了、標準ライブラリ | 小さい、依存少ない |
| Python | インタプリタ     | バイトコード実行、GC      | インタプリタが必要 |
| Java   | VM               | バイトコード実行、JIT、GC | JVM が必要         |
| Go     | 組み込み         | スケジューラ、GC          | 大きめ、依存なし   |

<strong>注意</strong>：この比較は「言語比較」が目的ではありません

「ランタイムにはさまざまな形がある」ことを示すための例です

---

## ランタイムとプロセスの関係

前のシリーズで学んだ「プロセス」と、ランタイムはどのような関係にあるのでしょうか？

### ランタイムはプロセス内で動く

ランタイムは、プロセスの中で動いています

OS から見ると、ランタイムは「プログラムの一部」でしかありません

Python プログラムを実行すると、OS は `python` プロセスを作成します

そのプロセスの中で、インタプリタ（ランタイム）がソースコードを実行しています

```
┌─────────────────────────────────────────┐
│              プロセス                    │
│                                         │
│   ┌─────────────────────────────────┐   │
│   │      ユーザーのコード             │   │
│   └─────────────────────────────────┘   │
│                  ↓                      │
│   ┌─────────────────────────────────┐   │
│   │         ランタイム               │   │
│   │   ・メモリ管理                   │   │
│   │   ・言語機能の実現               │   │
│   │   ・OS との橋渡し                │   │
│   └─────────────────────────────────┘   │
│                  ↓                      │
│   ┌─────────────────────────────────┐   │
│   │      OS（システムコール）         │   │
│   └─────────────────────────────────┘   │
│                                         │
└─────────────────────────────────────────┘
```

### メモリ構造との対応

01-process で学んだメモリ構造を思い出してください

プロセスのメモリは、テキスト、データ、ヒープ、スタックの領域に分かれています

ランタイムもこのメモリ構造の中に存在します

| メモリ領域 | 内容                                  |
| ---------- | ------------------------------------- |
| テキスト   | ユーザーのコード + ランタイムのコード |
| データ     | 静的変数、グローバル変数              |
| ヒープ     | ランタイムが管理する動的メモリ        |
| スタック   | 関数呼び出し、ローカル変数            |

C 言語の場合、libc のコードもテキスト領域に読み込まれます

Go の場合、ランタイム（スケジューラ、GC など）のコードもバイナリに含まれ、テキスト領域に配置されます

---

## ランタイムと OS の境界

ランタイムと OS は、それぞれどこまでの責任を持っているのでしょうか？

### OS の責務

OS（カーネル）は、以下のことを担当しています

- <strong>プロセス管理</strong>：プロセスの作成、終了、スケジューリング
- <strong>仮想メモリ</strong>：各プロセスに独立したアドレス空間を提供
- <strong>ファイルシステム</strong>：ファイルの読み書き
- <strong>ネットワークスタック</strong>：TCP/IP などの通信

これらはカーネル空間の学習で詳しく学べます

### ランタイムの責務

ランタイムは、OS が提供する「原始的な機能」を使って、より高レベルな機能を実現します

- <strong>ヒープメモリの細かい管理</strong>
  - OS から借りた大きなメモリブロックを、小さく切り分ける
- <strong>軽量スレッドの管理</strong>
  - OS のスレッドの上に、より軽量なスレッド（goroutine など）を実現
- <strong>言語レベルの API</strong>
  - OS のシステムコールをラップして、使いやすい API を提供

### 境界の例：メモリ管理

メモリ管理で、OS とランタイムの境界を見てみましょう

| 層         | 役割                                                                             |
| ---------- | -------------------------------------------------------------------------------- |
| OS         | 仮想メモリ空間を提供する（`mmap`、`brk` などメモリ領域を確保するシステムコール） |
| ランタイム | OS から借りたメモリを細かく管理する（`malloc`）                                  |
| ユーザー   | `malloc()` を呼び出してメモリを使う                                              |

ユーザーが `malloc(100)` で 100 バイトを要求すると、ランタイムは手持ちのメモリから 100 バイトを切り出して返します

手持ちが足りなければ、OS から追加のメモリを借りてきます

### 境界の例：並行処理

並行処理でも、OS とランタイムの境界があります

| 層         | 役割                                                 |
| ---------- | ---------------------------------------------------- |
| OS         | スレッド機構を提供する（`clone` システムコールなど） |
| ランタイム | 軽量スレッドを実現する（goroutine など）             |
| ユーザー   | `go func()` で goroutine を起動する                  |

Go の goroutine は、OS のスレッド（数個〜数十個）の上で、数千〜数万の goroutine を動かします

この「軽量スレッドのスケジューリング」がランタイムの仕事です

### まとめ

| 機能         | OS の責務              | ランタイムの責務             |
| ------------ | ---------------------- | ---------------------------- |
| メモリ       | 仮想メモリ空間の提供   | ヒープの細かい管理           |
| 並行処理     | スレッドの提供         | 軽量スレッド / コルーチン    |
| ファイル     | ファイルディスクリプタ | 言語レベルのファイル API     |
| ネットワーク | ソケット               | 言語レベルのネットワーク API |

---

## ランタイムを観察してみよう

実際にランタイムの存在を確認してみましょう

### C 言語の場合：ldd コマンド

C 言語のプログラムがどのライブラリに依存しているかを確認できます

```bash
# hello という実行ファイルの依存ライブラリを確認
$ ldd ./hello
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f...)
    /lib64/ld-linux-x86-64.so.2 (0x00007f...)
```

`libc.so.6` が C 標準ライブラリ（ランタイムライブラリ）です

`ld-linux-x86-64.so.2` は動的リンカ（共有ライブラリをメモリに読み込むプログラム）で、プログラム起動時にライブラリを読み込みます

### Python の場合：プロセスを確認

Python スクリプトを実行して、プロセスを確認してみましょう

```bash
# Python スクリプトをバックグラウンドで実行
$ python3 -c "import time; time.sleep(60)" &
[1] 12345

# プロセスの実行ファイルを確認
$ ls -l /proc/12345/exe
lrwxrwxrwx 1 user user 0 ... /proc/12345/exe -> /usr/bin/python3.10
```

`/proc/[pid]/exe` を見ると、実際に動いているのは `python3.10` という実行ファイルであることがわかります

Python スクリプト（`.py` ファイル）自体がプロセスになっているのではなく、`python3` インタプリタがプロセスとして動いているのです

### Java の場合：java -version

Java の場合、JVM のバージョンを確認できます

```bash
$ java -version
openjdk version "21"
OpenJDK Runtime Environment
OpenJDK 64-Bit Server VM (mixed mode, sharing)
```

「OpenJDK Runtime Environment」と表示されています

これが Java のランタイム環境です

### Go の場合：バイナリサイズ

Go でシンプルなプログラムをコンパイルして、サイズを確認してみましょう

```bash
# Hello World プログラム
$ cat hello.go
package main
import "fmt"
func main() { fmt.Println("Hello") }

# コンパイル
$ go build hello.go

# サイズを確認
$ ls -lh hello
-rwxr-xr-x 1 user user 1.8M ... hello
```

「Hello World」だけで約 1.8MB のバイナリになります

これは、Go のランタイム（スケジューラ、GC など）がバイナリに含まれているためです

比較として、C 言語の Hello World は数 KB 程度です

---

## 用語集

| 用語                 | 英語                     | 説明                                         |
| -------------------- | ------------------------ | -------------------------------------------- |
| ランタイム           | Runtime                  | プログラムを実行するためのソフトウェア環境   |
| 実行時               | Runtime / Execution time | プログラムが実行されている時間・状態         |
| コンパイル時         | Compile time             | プログラムがコンパイルされる時間・状態       |
| インタプリタ         | Interpreter              | ソースコードを逐次解釈して実行するプログラム |
| 仮想マシン           | Virtual Machine / VM     | バイトコードを実行するソフトウェア           |
| バイトコード         | Bytecode                 | VM 向けの中間コード                          |
| 標準ライブラリ       | Standard Library         | 言語に付属するライブラリ                     |
| ガベージコレクション | Garbage Collection / GC  | 不要なメモリを自動で解放する仕組み           |
| システムコール       | System Call              | OS の機能を呼び出す仕組み                    |
| ヒープ               | Heap                     | 動的に確保されるメモリ領域                   |
| スタック             | Stack                    | ローカル変数が置かれるメモリ領域             |
| libc                 | libc                     | C 標準ライブラリの実装                       |
| JVM                  | Java Virtual Machine     | Java のバイトコードを実行する仮想マシン      |
| CPython              | CPython                  | Python の標準実装（C 言語で書かれている）    |
| GIL                  | Global Interpreter Lock  | CPython でマルチスレッドを制限する仕組み     |
| JIT                  | Just-In-Time Compilation | 実行時に機械語にコンパイルする方式           |
| goroutine            | goroutine                | Go の軽量スレッド                            |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>言語ランタイム</strong>

- [Go Runtime](https://pkg.go.dev/runtime)
  - Go ランタイムの公式ドキュメント
- [CPython Internals](https://devguide.python.org/internals/)
  - Python インタプリタの内部構造
- [The Java Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se21/html/index.html)
  - JVM の公式仕様

<strong>C ランタイム</strong>

- [GNU C Library Manual](https://www.gnu.org/software/libc/manual/)
  - libc の詳細

<strong>観察・確認用</strong>

- [proc(5) - Linux manual page](https://man7.org/linux/man-pages/man5/proc.5.html)
  - /proc ファイルシステム
- [ldd(1) - Linux manual page](https://man7.org/linux/man-pages/man1/ldd.1.html)
  - 動的リンクの確認

---

## 次のステップ

このトピックでは、「ランタイムとは何か」の全体像を学びました

次の [02-compilation](./02-compilation.md) では、プログラムが「実行可能な形」になるまでの過程を学びます

- ソースコードはどうやって実行可能になるのか
- インタプリタ、コンパイラ、JIT の違い
- なぜ言語によって実行方法が異なるのか

これらの疑問に答えていきます
