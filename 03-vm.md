<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 03-vm：仮想マシンとバイトコード

## はじめに

[02-compilation](./02-compilation.md) で、プログラムが実行可能な形になるまでの過程を学びました

インタプリタや JIT コンパイラは「バイトコード」を実行すると説明しました

しかし、バイトコードとは何でしょうか？

そして、誰がバイトコードを実行しているのでしょうか？

答えは<strong>「仮想マシン（VM）」</strong>です

Java が「どの OS でも動く」と言われるのは、JVM という仮想マシンがあるからです

Python のプログラムを実行しているのも、CPython VM という仮想マシンです

このページでは、仮想マシンとバイトコードの仕組みを学びます

### 日常の例え

国際会議を想像してください

各国の代表が、それぞれの母国語で発言しています

しかし、全員が全ての言語を理解できるわけではありません

そこで、<strong>共通語</strong>を使うことにします

各国の代表は、まず自分の発言を共通語に翻訳します

そして、各国には<strong>通訳者</strong>がいて、共通語を母国語に翻訳します

| プログラミングの世界 | 国際会議の例え                       |
| -------------------- | ------------------------------------ |
| ソースコード         | 各国語での発言                       |
| バイトコード         | 共通語（エスペラント語のようなもの） |
| 仮想マシン           | 各国の通訳者                         |
| 機械語               | 聞き手が理解できる母国語             |

Java が「Write Once, Run Anywhere」を実現できるのは、この仕組みのおかげです

同じバイトコード（共通語）を、各プラットフォームの JVM（通訳者）が実行するのです

### このページで学ぶこと

このページでは、以下の概念を学びます

- <strong>仮想マシンとは何か</strong>
  - ソフトウェアで実現された実行環境
- <strong>バイトコードとは何か</strong>
  - 仮想マシン向けの中間コード
- <strong>主要な仮想マシン</strong>
  - JVM、CPython VM、V8 の特徴
- <strong>仮想マシンの動作原理</strong>
  - フェッチ・デコード・実行サイクル

---

## 目次

1. [なぜ仮想マシンが必要か](#なぜ仮想マシンが必要か)
2. [バイトコードとは何か](#バイトコードとは何か)
3. [主要な仮想マシン](#主要な仮想マシン)
4. [仮想マシンの動作原理](#仮想マシンの動作原理)
5. [仮想マシンとプロセスの関係](#仮想マシンとプロセスの関係)
6. [WebAssembly への言及](#webassembly-への言及)
7. [用語集](#用語集)
8. [参考資料](#参考資料)
9. [次のステップ](#次のステップ)

---

## なぜ仮想マシンが必要か

なぜ、ソースコードを直接機械語にコンパイルせず、仮想マシンを使うのでしょうか？

### プラットフォーム非依存性

最大の理由は<strong>プラットフォーム非依存性</strong>です

C 言語でプログラムを書くと、Windows 用、Linux 用、macOS 用に別々にコンパイルする必要があります

しかし、Java でプログラムを書くと、一度コンパイルしたバイトコードをどの環境でも実行できます

```
Java の場合：
Hello.java → [javac] → Hello.class → どの JVM でも実行可能

C の場合：
hello.c → [gcc] → hello（Linux 専用）
hello.c → [gcc] → hello.exe（Windows 専用）
```

### セキュリティ

仮想マシンは<strong>サンドボックス</strong>（隔離された安全な実行環境）として機能することもできます

バイトコードを実行する前に、仮想マシンが安全性を検証できます

JVM は、バイトコードが不正なメモリアクセスをしないかチェックします

Web ブラウザ内で JavaScript が動くのも、V8 がサンドボックスを提供しているからです

### 実行時最適化

JIT コンパイラを持つ仮想マシンは、<strong>実行時の情報</strong>を使って最適化できます

AOT コンパイラは、コンパイル時の情報しか使えません

しかし、JIT コンパイラは「この関数がよく呼ばれる」「この分岐はほとんど true になる」といった情報を観察できます

これにより、実行パターンに特化した最適化が可能になります

### メリットとデメリット

| 項目         | メリット                   | デメリット               |
| ------------ | -------------------------- | ------------------------ |
| 移植性       | 一度書けばどこでも動く     | VM が必要                |
| セキュリティ | サンドボックス、検証が可能 | オーバーヘッド           |
| 最適化       | 実行時情報を使える         | 起動時のコンパイルコスト |
| 開発効率     | デバッグしやすい           | メモリ使用量が多い       |

---

## バイトコードとは何か

### 中間コードとしてのバイトコード

<strong>バイトコード</strong>は、ソースコードと機械語の「中間」に位置するコードです

機械語よりも高レベルで、ソースコードよりも低レベルです

| レベル               | 例                                  |
| -------------------- | ----------------------------------- |
| 高レベル             | `System.out.println("Hello");`      |
| 中間（バイトコード） | `getstatic`, `ldc`, `invokevirtual` |
| 低レベル（機械語）   | `0x48 0x89 0xe5 ...`                |

バイトコードは、仮想マシン向けの「命令」です

人間には読みにくいですが、機械語ほど CPU 依存ではありません

### スタックベースとレジスタベース

仮想マシンの設計には、大きく 2 つの方式があります

<strong>スタックベース</strong>

JVM や CPython VM はスタックベースです

演算はスタック上で行われます

```
例：1 + 2 を計算する

push 1    # スタックに 1 を積む
push 2    # スタックに 2 を積む
add       # スタックから 2 つ取り出し、足して結果を積む
```

<strong>レジスタベース</strong>

Lua VM や一部の実装はレジスタベースです

演算は仮想レジスタ間で行われます

```
例：1 + 2 を計算する

load r1, 1    # レジスタ r1 に 1 を格納
load r2, 2    # レジスタ r2 に 2 を格納
add r3, r1, r2  # r1 と r2 を足して r3 に格納
```

| 方式           | 特徴                       | 代表的な VM         |
| -------------- | -------------------------- | ------------------- |
| スタックベース | 命令が簡潔、実装が容易     | JVM、CPython VM     |
| レジスタベース | 命令数が少ない、実行が高速 | Lua VM、V8 Ignition |

多くの主要な VM はスタックベースを採用しています

#### 歴史的背景

スタックベース VM は Forth 言語とともに普及しました

Forth は「後置記法」（1 2 + のように演算子を後に書く）を採用し、スタックを使った計算を言語の中心に据えました

この設計は実装が単純で、メモリ効率も良いため、初期の仮想マシンの多くがスタックベースを採用しました

Java VM（JVM）もスタックベースです

上の例を比較すると、スタックベースの `add` 命令はオペランドを指定していません

「スタックの一番上の 2 つ」を暗黙的に使うため、命令が短くなります

また、`1 + 2` という式は「1 を積む → 2 を積む → 足す」とそのまま変換できるため、コンパイラの実装も容易です

---

## 主要な仮想マシン

実際に使われている仮想マシンを見てみましょう

### JVM（Java Virtual Machine）

<strong>JVM</strong> は、Java のバイトコードを実行する仮想マシンです

Java だけでなく、Kotlin、Scala、Groovy など多くの言語が JVM 上で動作します

| 特徴         | 説明                             |
| ------------ | -------------------------------- |
| バイトコード | `.class` ファイル                |
| 方式         | スタックベース                   |
| JIT          | HotSpot JIT コンパイラ           |
| GC           | 複数の GC 実装（G1GC、ZGC など） |

JVM は、バイトコードを最初はインタプリタで実行します

頻繁に実行されるメソッドを検出すると、JIT コンパイラで機械語に変換します

### CPython VM

<strong>CPython VM</strong> は、Python の標準実装が使用する仮想マシンです

Python のソースコードは、まずバイトコード（`.pyc`）に変換され、CPython VM で実行されます

| 特徴         | 説明                                  |
| ------------ | ------------------------------------- |
| バイトコード | `.pyc` ファイル                       |
| 方式         | スタックベース                        |
| JIT          | 標準では JIT なし（PyPy は JIT あり） |
| GC           | 参照カウント + 循環参照検出           |

CPython は JIT を持たないため、実行速度は JVM より遅くなります

しかし、起動が速く、動的な言語機能を活かした開発が可能です

### V8

<strong>V8</strong> は、Google が開発した JavaScript エンジンです

Chrome ブラウザや Node.js で使用されています

| 特徴         | 説明                       |
| ------------ | -------------------------- |
| インタプリタ | Ignition（レジスタベース） |
| JIT          | TurboFan（最適化 JIT）     |
| GC           | 世代別 GC                  |

V8 は、JavaScript をバイトコードに変換した後、Ignition インタプリタで実行します

頻繁に実行されるコードは TurboFan で高度に最適化されます

### 比較表

| 仮想マシン | 言語         | 方式           | JIT  |
| ---------- | ------------ | -------------- | ---- |
| JVM        | Java, Kotlin | スタックベース | あり |
| CPython VM | Python       | スタックベース | なし |
| V8         | JavaScript   | レジスタベース | あり |

---

## 仮想マシンの動作原理

仮想マシンは、どのようにバイトコードを実行しているのでしょうか？

### フェッチ・デコード・実行

仮想マシンは、実際の CPU と似たサイクルで動作します

1. <strong>フェッチ</strong>：次の命令を読み込む
2. <strong>デコード</strong>：命令を解釈する
3. <strong>実行</strong>：命令を実行する

このサイクルを、プログラムが終了するまで繰り返します

### インタプリタの実装

インタプリタの基本的な構造は、以下のようなループです

```c
while (running) {
    opcode = fetch_next_instruction();
    switch (opcode) {
        case PUSH:
            push(stack, operand);
            break;
        case ADD:
            b = pop(stack);
            a = pop(stack);
            push(stack, a + b);
            break;
        case PRINT:
            value = pop(stack);
            printf("%d\n", value);
            break;
        /* ... 他の命令 ... */
    }
}
```

このように、バイトコードの各命令に対応する処理を実行していきます

### JIT コンパイルへの移行

インタプリタだけでは実行速度に限界があります

そこで、JIT コンパイラが登場します

```
1. インタプリタで実行開始
2. 実行パターンを観察（どのコードが何回実行されたかを記録）
3. 頻繁に実行されるコード（ホットスポット）を検出
4. ホットスポットを機械語にコンパイル
5. 次回以降は機械語で直接実行
```

このアプローチにより、「起動は速く、長時間動作すると高速になる」という特性が実現されます

---

## 仮想マシンとプロセスの関係

カーネル空間の学習で学んだ仮想メモリと、仮想マシンはどう関係するのでしょうか？

### OS から見た仮想マシン

OS から見ると、JVM も CPython も「普通のプロセス」でしかありません

仮想マシンは、OS が提供する仮想メモリ空間の中で動作しています

```
┌─────────────────────────────────────────┐
│              プロセス                    │
│                                         │
│   ┌─────────────────────────────────┐   │
│   │      Java プログラム              │   │
│   └─────────────────────────────────┘   │
│                  ↓                      │
│   ┌─────────────────────────────────┐   │
│   │         JVM                       │   │
│   │   ・バイトコード実行              │   │
│   │   ・JIT コンパイル                │   │
│   │   ・GC                            │   │
│   └─────────────────────────────────┘   │
│                  ↓                      │
│   ┌─────────────────────────────────┐   │
│   │      OS（仮想メモリ）             │   │
│   └─────────────────────────────────┘   │
│                                         │
└─────────────────────────────────────────┘
```

### メモリ管理の二重構造

仮想マシンは、OS から借りたメモリを独自に管理しています

| 層             | メモリ管理                     |
| -------------- | ------------------------------ |
| OS             | 仮想メモリ空間を提供（`mmap`） |
| 仮想マシン     | ヒープを管理、GC を実行        |
| ユーザーコード | オブジェクトを作成             |

Java で `new Object()` を呼ぶと、JVM が管理するヒープからメモリが割り当てられます

JVM が持つメモリが足りなくなると、OS から追加のメモリを借りてきます

---

## WebAssembly への言及

近年、新しい形の仮想マシンとして<strong>WebAssembly（Wasm）</strong>が注目されています

### WebAssembly とは

WebAssembly は、Web ブラウザで高速に実行できるバイナリ形式です

元々は「ブラウザで C/C++ を動かす」ために設計されました

| 特徴           | 説明                                                |
| -------------- | --------------------------------------------------- |
| バイナリ形式   | コンパクトで高速にデコード可能                      |
| 言語非依存     | C、C++、Rust、Go などから生成可能                   |
| サンドボックス | ブラウザ内で安全に実行                              |
| 移植性         | ブラウザ以外でも実行可能（Wasmer などのランタイム） |

### なぜ WebAssembly が重要か

WebAssembly は、仮想マシンの新しい可能性を示しています

- ブラウザ内でネイティブに近い速度を実現（バイナリ形式で高速にデコード・コンパイルできるため）
- 言語に依存しない「新しい共通語」
- サーバーサイドでも使える汎用性

JVM が「Java の共通語」であるのに対し、WebAssembly は「言語を問わない共通語」を目指しています

---

## 用語集

| 用語           | 英語                    | 説明                                    |
| -------------- | ----------------------- | --------------------------------------- |
| 仮想マシン     | Virtual Machine / VM    | バイトコードを実行するソフトウェア      |
| バイトコード   | Bytecode                | 仮想マシン向けの中間コード              |
| JVM            | Java Virtual Machine    | Java のバイトコードを実行する仮想マシン |
| CPython VM     | CPython Virtual Machine | Python の標準実装が使用する仮想マシン   |
| V8             | V8 Engine               | Google の JavaScript エンジン           |
| スタックベース | Stack-based             | スタックを使って演算する VM 設計        |
| レジスタベース | Register-based          | 仮想レジスタを使って演算する VM 設計    |
| フェッチ       | Fetch                   | 次の命令を読み込むこと                  |
| デコード       | Decode                  | 命令を解釈すること                      |
| ホットスポット | Hotspot                 | 頻繁に実行されるコード部分              |
| サンドボックス | Sandbox                 | 隔離された安全な実行環境                |
| WebAssembly    | WebAssembly / Wasm      | Web 向けの移植可能なバイナリ形式        |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>JVM</strong>

- [The Java Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se21/html/index.html)
  - JVM の公式仕様
- [Java SE HotSpot Virtual Machine](https://docs.oracle.com/en/java/javase/21/vm/)
  - HotSpot VM のドキュメント

<strong>Python</strong>

- [CPython Internals](https://devguide.python.org/internals/)
  - CPython の内部構造

<strong>JavaScript</strong>

- [V8 Documentation](https://v8.dev/docs)
  - V8 エンジンの公式ドキュメント

<strong>WebAssembly</strong>

- [WebAssembly Specification](https://webassembly.github.io/spec/)
  - WebAssembly の公式仕様

---

## 次のステップ

このトピックでは、仮想マシンとバイトコードの仕組みを学びました

仮想マシンは、ヒープメモリを管理し、ガベージコレクションを行うと説明しました

次の [04-stack-heap](./04-stack-heap.md) では、このメモリ管理の基本である<strong>「スタックとヒープ」</strong>について学びます

- なぜ 2 つのメモリ領域があるのか
- スタックとヒープの違い
- 言語によるメモリモデルの違い

これらの疑問に答えていきます
